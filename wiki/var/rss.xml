<rss version="2.0">
<channel>
<title>TPTElements</title>
<link>http://localhost:80/tptelements/wiki/index.php</link>
<description>RSS feed from TPTElements</description>
<language>en-US</language>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 18:44:13 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Methods

!! partNeighbours
{{[int] sim.partNeighbours (int x, int y, int radius)
[int] sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particle indexes around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.



!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to create a particle without checking if there's a particle or wall or anything already there, meaning the new particle will stack over the existing particle.
Otherwise, set {.hl}newindex{/} to any existing index to replace the particle with that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}



!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int sim.partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int sim.partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil sim.partKill (int index)
nil sim.partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float sim.pressure (int x, int y)
nil sim.pressure (int x, int y, float value)
nil sim.pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float sim.ambientHeat (int x, int y)
nil sim.ambientHeat (int x, int y, float value)
nil sim.ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float sim.velocityX (int x, int y)
nil sim.velocityX (int x, int y, float value)
nil sim.velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float sim.velocityY (int x, int y)
nil sim.velocityY (int x, int y, float value)
nil sim.velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil sim.gravMap (int x, int y, float value)
nil sim.gravMap (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int sim.createParts (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.

!! reloadSave
{{nil sim.reloadSave ()}}
Reload the current save.

!! adjustCoords
{{int, int adjustCoords (int x, int y)}}
Translates zoom window coordinates to absolute coordinates. If there isn't a zoom window at the coordinates, returns the same coordinates as before.


!! prettyPowders
{{nil prettyPowders (boolint on)
boolint prettyPowders ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 
!!! Defaults
on = 0

!! gravityGrid
{{nil gravityGrid (boolint on)
boolint gravityGrid ()}}
Gets or sets whether there's a gravity grid showing Newtonian Gravity vectors.
!!! Defaults
on = 0

!! edgeMode
{{nil edgeMode (int mode)
int edgeMode ()}}
Gets or sets the current edge mode (either void or solid)

!!! Edge modes 
Void = 0 {br} Solid = 1 

!!! Defaults
mode = 0

!! gravityMode
{{nil gravityMode (int mode)
int gravityMode ()}}
Gets or sets the current gravity mode (vertical, radial, none)
!!! Gravity modes
Vertical = 0 {br}
Off = 1 {br}
Radial = 2

!!! Defaults
mode = 0

!! airMode
{{nil airMode (int mode)
int airMode ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 

!!! Air modes
On = 0 {br}
Pressure off = 1 {br}
Velocity off = 2 {br}
All off = 3 {br} 
No update {br}

!!! Defaults
mode = 0

!! waterEqualisation
{{nil waterEqualisation (boolint on)
boolint waterEqualisation ()}}
Gets or sets whether liquids try to adjust their levels through walls. Kind of slow, but your computer will probably handle it!

!!! Defaults
on = 0


!! ambientAirTemp
{{nil ambientAirTemp (float newvalue)
float ambientAirTemp ()}}
Gets or sets the ambient air temperature.

!!! Defaults
newvalue = 273.15 + 20.0 = 293.15

!! elementCount
{{int sim.elementCount (element type)}}
Returns how many particles exist of a given type. 

!!! Defaults
type = 0 (invalid type, so the elementCount also returns 0)

!! canMove
{{int sim.canMove (element from, element to)}}
Returns a can_move value for if the from element can move into the to element. This table is generated at startup, and won't usually change during gameplay. Maybe when new elements are added.

!!! Values

0 = Don't move into the element, or bounce off. {br} 1 = Swap places. {br} 2 = Both particles can overlap. {br} 3 = Depends on other things, so we can't be sure.

!! parts
{{iterator&amp;lt;int&gt; sim.parts ()}}
If you for..in loop over its return value, you get a valid particle index every call.
For example, if we place four particles, #0, #1, #2, and #3, and delete #2, then the valid indices would be #0, #1 and #3, because those still contain an element. You don't have to manually loop over all indices checking if there's a particle, just use this function instead.

!! pmap
{{int sim.pmap (int x, int y)}}
Returns the pmap value at x, y, cutting off the particle type. This 24-bit value can contain different kinds of data, generally the particle index. (?)

!! neighbours

{{iterator&amp;lt;int, int, int&gt; sim.neighbours(int x, int y, int radiusx, int radiusy)}}
Goes over nearby particles in a given radius (the diameter would be 2 x radius + 1), returning their index as well as their x and y coordinates.
You can use this in a for..in loop: 
{{for index, x, y in sim.neighbours(100, 100, 4, 4) do
    -- ...
end}}


! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

<ins>{tags:Simulation, fields, sim}</ins>
</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 18:42:31 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Methods

!! partNeighbours
{{[int] sim.partNeighbours (int x, int y, int radius)
[int] sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particle indexes around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.



!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to create a particle without checking if there's a particle or wall or anything already there, meaning the new particle will stack over the existing particle.
Otherwise, set {.hl}newindex{/} to any existing index to replace the particle with that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}



!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int sim.partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int sim.partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil sim.partKill (int index)
nil sim.partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float sim.pressure (int x, int y)
nil sim.pressure (int x, int y, float value)
nil sim.pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float sim.ambientHeat (int x, int y)
nil sim.ambientHeat (int x, int y, float value)
nil sim.ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float sim.velocityX (int x, int y)
nil sim.velocityX (int x, int y, float value)
nil sim.velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float sim.velocityY (int x, int y)
nil sim.velocityY (int x, int y, float value)
nil sim.velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil sim.gravMap (int x, int y, float value)
nil sim.gravMap (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int sim.createParts (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.

!! reloadSave
{{nil sim.reloadSave ()}}
Reload the current save.

!! adjustCoords
{{int, int adjustCoords (int x, int y)}}
Translates zoom window coordinates to absolute coordinates.<ins> If there isn't a zoom window at the coordinates, returns the same coordinates as before.
</ins>

!! prettyPowders
{{nil prettyPowders (boolint on)
boolint prettyPowders ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 
!!! Defaults
on = 0

!! gravityGrid
{{nil gravityGrid (boolint on)
boolint gravityGrid ()}}
Gets or sets whether there's a gravity grid showing Newtonian Gravity vectors.
!!! Defaults
on = 0

!! edgeMode
{{nil edgeMode (int mode)
int edgeMode ()}}
Gets or sets the current edge mode (either void or solid)

!!! Edge modes 
Void = 0 {br} Solid = 1 

!!! Defaults
mode = 0

!! gravityMode
{{nil gravityMode (int mode)
int gravityMode ()}}
Gets or sets the current gravity mode (vertical, radial, none)
!!! Gravity modes
Vertical = 0 {br}
Off = 1 {br}
Radial = 2

!!! Defaults
mode = 0

!! airMode
{{nil airMode (int mode)
int airMode ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 

!!! Air modes
On = 0 {br}
Pressure off = 1 {br}
Velocity off = 2 {br}
All off = 3 {br} 
No update {br}

!!! Defaults
mode = 0

!! waterEqualisation
{{nil waterEqualisation (boolint on)
boolint waterEqualisation ()}}
Gets or sets whether liquids try to adjust their levels through walls. Kind of slow, but your computer will probably handle it!

!!! Defaults
on = 0


!! ambientAirTemp
{{nil ambientAirTemp (float newvalue)
float ambientAirTemp ()}}
Gets or sets the ambient air temperature.

!!! Defaults
newvalue = 273.15 + 20.0 = 293.15

!! elementCount
{{int sim.elementCount (element type)}}
Returns how many particles exist of a given type. 

!!! Defaults
type = 0 (invalid type, so the elementCount also returns 0)

!! canMove
{{int sim.canMove (element from, element to)}}
Returns a can_move value for if the from element can move into the to element. This table is generated at startup, and won't usually change during gameplay. Maybe when new elements are added.

!!! Values

0 = Don't move into the element, or bounce off. {br} 1 = Swap places. {br} 2 = Both particles can overlap. {br} 3 = Depends on other things, so we can't be sure.

!! parts
{{iterator&amp;lt;int&gt; sim.parts ()}}
If you for..in loop over its return value, you get a valid particle index every call.
For example, if we place four particles, #0, #1, #2, and #3, and delete #2, then the valid indices would be #0, #1 and #3, because those still contain an element. You don't have to manually loop over all indices checking if there's a particle, just use this function instead.

!! pmap
{{int sim.pmap (int x, int y)}}
Returns the pmap value at x, y, cutting off the particle type. This 24-bit value can contain different kinds of data, generally the particle index. (?)

!! neighbours

{{iterator&amp;lt;int, int, int&gt; sim.neighbours(int x, int y, int radiusx, int radiusy)}}
Goes over nearby particles in a given radius (the diameter would be 2 x radius + 1), returning their index as well as their x and y coordinates.
You can use this in a for..in loop: 
{{for index, x, y in sim.neighbours(100, 100, 4, 4) do
    -- ...
end}}


! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 18:40:58 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Methods

!! partNeighbours
{{[int] sim.partNeighbours (int x, int y, int radius)
[int] sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particle indexes around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.



!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to <del>'skip pmap checks'. 
Otherwise,</del><ins>create a particle without checking if there's a particle or wall or anything already there, meaning the new particle will stack over the existing particle.
Otherwise,</ins> set {.hl}newindex{/} to any existing index to replace<ins> the particle with</ins> that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}
<ins></ins>


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int sim.partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int sim.partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil sim.partKill (int index)
nil sim.partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float sim.pressure (int x, int y)
nil sim.pressure (int x, int y, float value)
nil sim.pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float sim.ambientHeat (int x, int y)
nil sim.ambientHeat (int x, int y, float value)
nil sim.ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float sim.velocityX (int x, int y)
nil sim.velocityX (int x, int y, float value)
nil sim.velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float sim.velocityY (int x, int y)
nil sim.velocityY (int x, int y, float value)
nil sim.velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil sim.gravMap (int x, int y, float value)
nil sim.gravMap (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int sim.createParts (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.

!! reloadSave
{{nil sim.reloadSave ()}}
Reload the current save.

!! adjustCoords
{{int, int adjustCoords (int x, int y)}}
Translates zoom window coordinates to absolute coordinates.

!! prettyPowders
{{nil prettyPowders (boolint on)
boolint prettyPowders ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 
!!! Defaults
on = 0

!! gravityGrid
{{nil gravityGrid (boolint on)
boolint gravityGrid ()}}
Gets or sets whether there's a gravity grid showing Newtonian Gravity vectors.
!!! Defaults
on = 0

!! edgeMode
{{nil edgeMode (int mode)
int edgeMode ()}}
Gets or sets the current edge mode (either void or solid)

!!! Edge modes 
Void = 0 {br} Solid = 1 

!!! Defaults
mode = 0

!! gravityMode
{{nil gravityMode (int mode)
int gravityMode ()}}
Gets or sets the current gravity mode (vertical, radial, none)
!!! Gravity modes
Vertical = 0 {br}
Off = 1 {br}
Radial = 2

!!! Defaults
mode = 0

!! airMode
{{nil airMode (int mode)
int airMode ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 

!!! Air modes
On = 0 {br}
Pressure off = 1 {br}
Velocity off = 2 {br}
All off = 3 {br} 
No update {br}

!!! Defaults
mode = 0

!! waterEqualisation
{{nil waterEqualisation (boolint on)
boolint waterEqualisation ()}}
Gets or sets whether liquids try to adjust their levels through walls. Kind of slow, but your computer will probably handle it!

!!! Defaults
on = 0


!! ambientAirTemp
{{nil ambientAirTemp (float newvalue)
float ambientAirTemp ()}}
Gets or sets the ambient air temperature.

!!! Defaults
newvalue = 273.15 + 20.0 = 293.15

!! elementCount
{{int sim.elementCount (element type)}}
Returns how many particles exist of a given type. 

!!! Defaults
type = 0 (invalid type, so the elementCount also returns 0)

!! canMove
{{int sim.canMove (element from, element to)}}
Returns a can_move value for if the from element can move into the to element. This table is generated at startup, and won't usually change during gameplay. Maybe when new elements are added.

!!! Values

0 = Don't move into the element, or bounce off. {br} 1 = Swap places. {br} 2 = Both particles can overlap. {br} 3 = Depends on other things, so we can't be sure.

!! parts
{{iterator&amp;lt;int&gt; sim.parts ()}}
If you for..in loop over its return value, you get a valid particle index every call.
For example, if we place four particles, #0, #1, #2, and #3, and delete #2, then the valid indices would be #0, #1 and #3, because those still contain an element. You don't have to manually loop over all indices checking if there's a particle, just use this function instead.

!! pmap
{{int sim.pmap (int x, int y)}}
Returns the pmap value at x, y, cutting off the particle type. This 24-bit value can contain different kinds of data, generally the particle index. (?)

!! neighbours

{{iterator&amp;lt;int, int, int&gt; sim.neighbours(int x, int y, int radiusx, int radiusy)}}
Goes over nearby particles in a given radius (the diameter would be 2 x radius + 1), returning their index as well as their x and y coordinates.
You can use this in a for..in loop: 
{{for index, x, y in sim.neighbours(100, 100, 4, 4) do
    -- ...
end}}


! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 18:39:36 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Methods

!! partNeighbours
{{[int] sim.partNeighbours (int x, int y, int radius)
[int] sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particle indexes around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.



!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int sim.partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int sim.partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil sim.partKill (int index)
nil sim.partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float sim.pressure (int x, int y)
nil sim.pressure (int x, int y, float value)
nil sim.pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float sim.ambientHeat (int x, int y)
nil sim.ambientHeat (int x, int y, float value)
nil sim.ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float sim.velocityX (int x, int y)
nil sim.velocityX (int x, int y, float value)
nil sim.velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float sim.velocityY (int x, int y)
nil sim.velocityY (int x, int y, float value)
nil sim.velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil sim.gravMap (int x, int y, float value)
nil sim.gravMap (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int sim.createParts (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.

!! reloadSave
{{nil sim.reloadSave ()}}
Reload the current save.

!! adjustCoords
{{int, int adjustCoords (int x, int y)}}
Translates zoom window coordinates to absolute coordinates.

!! prettyPowders
{{nil prettyPowders (boolint on)
boolint prettyPowders ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 
!!! Defaults
on = 0

!! gravityGrid
{{nil gravityGrid (boolint on)
boolint gravityGrid ()}}
Gets or sets whether there's a gravity grid showing Newtonian Gravity vectors.
!!! Defaults
on = 0

!! edgeMode
{{nil edgeMode (int mode)
int edgeMode ()}}
Gets or sets the current edge mode (either void or solid)

!!! Edge modes 
Void = 0 {br} Solid = 1 

!!! Defaults
mode = 0

!! gravityMode
{{nil gravityMode (int mode)
int gravityMode ()}}
Gets or sets the current gravity mode (vertical, radial, none)
!!! Gravity modes
Vertical = 0 {br}
Off = 1 {br}
Radial = 2

!!! Defaults
mode = 0

!! airMode
{{nil airMode (int mode)
int airMode ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 

!!! Air modes
On = 0 {br}
Pressure off = 1 {br}
Velocity off = 2 {br}
All off = 3 {br} 
No update {br}

!!! Defaults
mode = 0

!! waterEqualisation
{{nil waterEqualisation (boolint on)
boolint waterEqualisation ()}}
Gets or sets whether liquids try to adjust their levels through walls. Kind of slow, but your computer will probably handle it!

!!! Defaults
on = 0


!! ambientAirTemp
{{nil ambientAirTemp (float newvalue)
float ambientAirTemp ()}}
Gets or sets the ambient air temperature.

!!! Defaults
newvalue = 273.15 + 20.0 = 293.15

!! elementCount
{{int sim.elementCount (element type)}}
Returns how many particles exist of a given type. 

!!! Defaults
type = 0 (invalid type, so the elementCount also returns 0)

!! canMove
{{int sim.canMove (element from, element to)}}
Returns a can_move value for if the from element can move into the to element. This table is generated at startup, and won't usually change during gameplay. Maybe when new elements are added.

!!! Values

0 = Don't move into the element, or bounce off. {br} 1 = Swap places. {br} 2 = Both particles can overlap. {br} 3 = Depends on other things, so we can't be sure.

!! parts
{{iterator&amp;lt;int&gt; sim.parts ()}}
If you for..in loop over its return value, you get a valid particle index every call.
For example, if we place four particles, #0, #1, #2, and #3, and delete #2, then the valid indices would be #0, #1 and #3, because those still contain an element. You don't have to manually loop over all indices checking if there's a particle, just use this function instead.

!! pmap
{{int sim.pmap (int x, int y)}}
Returns the pmap value at x, y, cutting off the particle type. This 24-bit value can contain different kinds of data, generally the particle index. (?)

!! neighbours

{{iterator&amp;lt;int, int, int&gt; sim.neighbours(int x, int y, int radiusx, int radiusy)}}
Goes over nearby particles in a given <del>radius,</del><ins>radius (the diameter would be 2 x radius + 1),</ins> returning their index as well as their x and y coordinates.<ins>
You can use this in a for..in loop: 
{{for index, x, y in sim.neighbours(100, 100, 4, 4) do
    -- ...
end}}</ins>


! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 18:38:13 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Methods

!! partNeighbours
{{[int] sim.partNeighbours (int x, int y, int radius)
[int] sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particle indexes around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.



!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int sim.partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int sim.partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil sim.partKill (int index)
nil sim.partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float sim.pressure (int x, int y)
nil sim.pressure (int x, int y, float value)
nil sim.pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float sim.ambientHeat (int x, int y)
nil sim.ambientHeat (int x, int y, float value)
nil sim.ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float sim.velocityX (int x, int y)
nil sim.velocityX (int x, int y, float value)
nil sim.velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float sim.velocityY (int x, int y)
nil sim.velocityY (int x, int y, float value)
nil sim.velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil sim.gravMap (int x, int y, float value)
nil sim.gravMap (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int sim.createParts (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.

!! reloadSave
{{nil sim.reloadSave ()}}
Reload the current save.

!! adjustCoords
{{int, int adjustCoords (int x, int y)}}
Translates zoom window coordinates to absolute coordinates.

!! prettyPowders
{{nil prettyPowders (boolint on)
boolint prettyPowders ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 
!!! Defaults
on = 0

!! gravityGrid
{{nil gravityGrid (boolint on)
boolint gravityGrid ()}}
Gets or sets whether there's a gravity grid showing Newtonian Gravity vectors.
!!! Defaults
on = 0

!! edgeMode
{{nil edgeMode (int mode)
int edgeMode ()}}
Gets or sets the current edge mode (either void or solid)

!!! Edge modes 
Void = 0 {br} Solid = 1 

!!! Defaults
mode = 0

!! gravityMode
{{nil gravityMode (int mode)
int gravityMode ()}}
Gets or sets the current gravity mode (vertical, radial, none)
!!! Gravity modes
Vertical = 0 {br}
Off = 1 {br}
Radial = 2

!!! Defaults
mode = 0

!! airMode
{{nil airMode (int mode)
int airMode ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 

!!! Air modes
On = 0 {br}
Pressure off = 1 {br}
Velocity off = 2 {br}
All off = 3 {br} 
No update {br}

!!! Defaults
mode = 0

!! waterEqualisation
{{nil waterEqualisation (boolint on)
boolint waterEqualisation ()}}
Gets or sets whether liquids try to adjust their levels through walls. Kind of slow, but your computer will probably handle it!

!!! Defaults
on = 0


!! ambientAirTemp
{{nil ambientAirTemp (float newvalue)
float ambientAirTemp ()}}
Gets or sets the ambient air temperature.

!!! Defaults
newvalue = 273.15 + 20.0 = 293.15

!! elementCount
{{int sim.elementCount (element type)}}
Returns how many particles exist of a given type. 

!!! Defaults
type = 0 (invalid type, so the elementCount also returns 0)

!! canMove
{{int sim.canMove (element from, element to)}}
Returns a can_move value for if the from element can move into the to element. This table is generated at startup, and won't usually change during gameplay. Maybe when new elements are added.

!!! Values

0 = Don't move into the element, or bounce off. {br} 1 = Swap places. {br} 2 = Both particles can overlap. {br} 3 = Depends on other things, so we can't be sure.

!! parts
{{iterator&amp;lt;int&gt; sim.parts ()}}
If you for..in loop over its return value, you get a valid particle index every call.
For example, if we place four particles, #0, #1, #2, and #3, and delete #2, then the valid indices would be #0, #1 and #3, because those still contain an element. You don't have to manually loop over all indices checking if there's a particle, just use this function instead.

!! pmap
{{int sim.pmap (int x, int y)}}
Returns the pmap value at x, y, cutting off the particle type. This 24-bit value can contain different kinds of data, generally the particle index. (?)

!! neighbours

<del>(to be written)</del><ins>{{iterator&amp;lt;int, int, int&gt; sim.neighbours(int x, int y, int radiusx, int radiusy)}}
Goes over nearby particles in a given radius, returning their index as well as their x and y coordinates.
</ins>

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 18:35:07 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Methods

!! partNeighbours
<del>{{table</del><ins>{{[int]</ins> sim.partNeighbours (int x, int y, int radius)<del>
table</del><ins>
[int]</ins> sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of <del>particles</del><ins>particle indexes</ins> around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.<ins>
</ins>


!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int sim.partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int sim.partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil sim.partKill (int index)
nil sim.partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float sim.pressure (int x, int y)
nil sim.pressure (int x, int y, float value)
nil sim.pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float sim.ambientHeat (int x, int y)
nil sim.ambientHeat (int x, int y, float value)
nil sim.ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float sim.velocityX (int x, int y)
nil sim.velocityX (int x, int y, float value)
nil sim.velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float sim.velocityY (int x, int y)
nil sim.velocityY (int x, int y, float value)
nil sim.velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil sim.gravMap (int x, int y, float value)
nil sim.gravMap (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int sim.createParts (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.

!! reloadSave
{{nil sim.reloadSave ()}}
Reload the current save.

!! adjustCoords
{{int, int adjustCoords (int x, int y)}}
Translates zoom window coordinates to absolute coordinates.

!! prettyPowders
{{nil prettyPowders (boolint on)
boolint prettyPowders ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 
!!! Defaults
on = 0

!! gravityGrid
{{nil gravityGrid (boolint on)
boolint gravityGrid ()}}
Gets or sets whether there's a gravity grid showing Newtonian Gravity vectors.
!!! Defaults
on = 0

!! edgeMode
{{nil edgeMode (int mode)
int edgeMode ()}}
Gets or sets the current edge mode (either void or solid)

!!! Edge modes 
Void = 0 {br} Solid = 1 

!!! Defaults
mode = 0

!! gravityMode
{{nil gravityMode (int mode)
int gravityMode ()}}
Gets or sets the current gravity mode (vertical, radial, none)
!!! Gravity modes
Vertical = 0 {br}
Off = 1 {br}
Radial = 2

!!! Defaults
mode = 0

!! airMode
{{nil airMode (int mode)
int airMode ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 

!!! Air modes
On = 0 {br}
Pressure off = 1 {br}
Velocity off = 2 {br}
All off = 3 {br} 
No update {br}

!!! Defaults
mode = 0

!! waterEqualisation
{{nil waterEqualisation (boolint on)
boolint waterEqualisation ()}}
Gets or sets whether liquids try to adjust their levels through walls. Kind of slow, but your computer will probably handle it!

!!! Defaults
on = 0


!! ambientAirTemp
{{nil ambientAirTemp (float newvalue)
float ambientAirTemp ()}}
Gets or sets the ambient air temperature.

!!! Defaults
newvalue = 273.15 + 20.0 = 293.15

!! elementCount
{{int sim.elementCount (element type)}}
Returns how many particles exist of a given type. 

!!! Defaults
type = 0 (invalid type, so the elementCount also returns 0)

!! canMove
{{int sim.canMove (element from, element to)}}
Returns a can_move value for if the from element can move into the to element. This table is generated at startup, and won't usually change during gameplay. Maybe when new elements are added.

!!! Values

0 = Don't move into the element, or bounce off. {br} 1 = Swap places. {br} 2 = Both particles can overlap. {br} 3 = Depends on other things, so we can't be sure.

!! parts
{{iterator&amp;lt;int&gt; sim.parts ()}}
If you for..in loop over its return value, you get a valid particle index every call.
For example, if we place four particles, #0, #1, #2, and #3, and delete #2, then the valid indices would be #0, #1 and #3, because those still contain an element. You don't have to manually loop over all indices checking if there's a particle, just use this function instead.

!! pmap
{{int sim.pmap (int x, int y)}}
Returns the pmap value at x, y, cutting off the particle type. This 24-bit value can contain different kinds of data, generally the particle index. (?)

!! neighbours

(to be written)

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 18:33:15 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Methods

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.


!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int sim.partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int sim.partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil sim.partKill (int index)
nil sim.partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float sim.pressure (int x, int y)
nil sim.pressure (int x, int y, float value)
nil sim.pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float sim.ambientHeat (int x, int y)
nil sim.ambientHeat (int x, int y, float value)
nil sim.ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float sim.velocityX (int x, int y)
nil sim.velocityX (int x, int y, float value)
nil sim.velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float sim.velocityY (int x, int y)
nil sim.velocityY (int x, int y, float value)
nil sim.velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil sim.gravMap (int x, int y, float value)
nil sim.gravMap (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int sim.createParts (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.
<ins>
!! reloadSave
{{nil sim.reloadSave ()}}
Reload the current save.

!! adjustCoords
{{int, int adjustCoords (int x, int y)}}
Translates zoom window coordinates to absolute coordinates.

!! prettyPowders
{{nil prettyPowders (boolint on)
boolint prettyPowders ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 
!!! Defaults
on = 0

!! gravityGrid
{{nil gravityGrid (boolint on)
boolint gravityGrid ()}}
Gets or sets whether there's a gravity grid showing Newtonian Gravity vectors.
!!! Defaults
on = 0

!! edgeMode
{{nil edgeMode (int mode)
int edgeMode ()}}
Gets or sets the current edge mode (either void or solid)

!!! Edge modes 
Void = 0 {br} Solid = 1 

!!! Defaults
mode = 0

!! gravityMode
{{nil gravityMode (int mode)
int gravityMode ()}}
Gets or sets the current gravity mode (vertical, radial, none)
!!! Gravity modes
Vertical = 0 {br}
Off = 1 {br}
Radial = 2

!!! Defaults
mode = 0

!! airMode
{{nil airMode (int mode)
int airMode ()}}
Gets or sets whether powders get slight decorative color adjustments on creation to make them look grainy. 

!!! Air modes
On = 0 {br}
Pressure off = 1 {br}
Velocity off = 2 {br}
All off = 3 {br} 
No update {br}

!!! Defaults
mode = 0

!! waterEqualisation
{{nil waterEqualisation (boolint on)
boolint waterEqualisation ()}}
Gets or sets whether liquids try to adjust their levels through walls. Kind of slow, but your computer will probably handle it!

!!! Defaults
on = 0


!! ambientAirTemp
{{nil ambientAirTemp (float newvalue)
float ambientAirTemp ()}}
Gets or sets the ambient air temperature.

!!! Defaults
newvalue = 273.15 + 20.0 = 293.15

!! elementCount
{{int sim.elementCount (element type)}}
Returns how many particles exist of a given type. 

!!! Defaults
type = 0 (invalid type, so the elementCount also returns 0)

!! canMove
{{int sim.canMove (element from, element to)}}
Returns a can_move value for if the from element can move into the to element. This table is generated at startup, and won't usually change during gameplay. Maybe when new elements are added.

!!! Values

0 = Don't move into the element, or bounce off. {br} 1 = Swap places. {br} 2 = Both particles can overlap. {br} 3 = Depends on other things, so we can't be sure.

!! parts
{{iterator&amp;lt;int&gt; sim.parts ()}}
If you for..in loop over its return value, you get a valid particle index every call.
For example, if we place four particles, #0, #1, #2, and #3, and delete #2, then the valid indices would be #0, #1 and #3, because those still contain an element. You don't have to manually loop over all indices checking if there's a particle, just use this function instead.

!! pmap
{{int sim.pmap (int x, int y)}}
Returns the pmap value at x, y, cutting off the particle type. This 24-bit value can contain different kinds of data, generally the particle index. (?)

!! neighbours

(to be written)</ins>

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 17:56:22 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.
<del>
! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;</del>

! Methods

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.


!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int <del>partPosition</del><ins>sim.partPosition</ins> (int index)}}
Returns x, y from a particle index.

!! partID

{{int <del>partID</del><ins>sim.partID</ins> (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil <del>partKill</del><ins>sim.partKill</ins> (int index)
nil <del>partKill</del><ins>sim.partKill</ins> (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float <del>pressure</del><ins>sim.pressure</ins> (int x, int y)
nil <del>pressure</del><ins>sim.pressure</ins> (int x, int y, float value)
nil <del>pressure</del><ins>sim.pressure</ins> (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float <del>ambientHeat</del><ins>sim.ambientHeat</ins> (int x, int y)
nil <del>ambientHeat</del><ins>sim.ambientHeat</ins> (int x, int y, float value)
nil <del>ambientHeat</del><ins>sim.ambientHeat</ins> (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float <del>velocityX</del><ins>sim.velocityX</ins> (int x, int y)
nil <del>velocityX</del><ins>sim.velocityX</ins> (int x, int y, float value)
nil <del>velocityX</del><ins>sim.velocityX</ins> (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float <del>velocityY</del><ins>sim.velocityY</ins> (int x, int y)
nil <del>velocityY</del><ins>sim.velocityY</ins> (int x, int y, float value)
nil <del>velocityY</del><ins>sim.velocityY</ins> (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil <del>velocityY</del><ins>sim.gravMap</ins> (int x, int y, float value)
nil <del>velocityY</del><ins>sim.gravMap</ins> (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int <del>createParts</del><ins>sim.createParts</ins> (int centerx, int centery, int radiusx, int radiusy, element type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.
<ins>
!!! Defaults

radiusx, radiusy = 5 {br} type = current tool {br} brush = CIRCLE_BRUSH {br} flags = current flags

Returns how many particles were changed in the process.

!! createLine

{{int sim.createLine (int x1, int y1, int x2, int y2, int rx, int ry, int type, int brush, int flags)}}
Creates a line of particles, using createParts.
Starting point is x1, y1, ending point is x2, y2. 
See [createParts|Lua-simulation#createParts].

!! createBox

{{int sim.createBox (int x1, int y1, int x2, int y2, int type, int flags)}}
Creates a filled box with the brushes, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createParts|Lua-simulation#createParts]. 

!! floodParts

{{int floodParts (int x, int y, element type, int cm, int flags)}}
Flood-fills an area with particles, starting from the position.  
If cm is -1, flood-deletes all particles (or walls!) starting from x,y with the type that x,y had. 
If cm is 0, flood-creates particles starting from x, y, of type type.

I'm not entirely sure on the cm part, actually. [You figure it out!|https://github.com/simtr/The-Powder-Toy/blob/8bc03dbe1c4068b416f5f7890d43bf6f6386c7dc/src/simulation/Simulation.cpp#L1439-L1461]

!! createWalls

{{int sim.createWalls (int x, int y, int radiusx, int radiusy, int walltype)}}
Create walls like a brush (the mouse) would. 

Returns how many walls were changed in the process.

!!! Defaults

x, y = -1 {br} radiusx, radiusy = 0 {br} walltype = 8 (block wall)

!! createWallLine

{{int sim.createWallLine (int x1, int y1, int x2, int y2, int rx, int ry, int walltype)}}
Creates a line of particles, using createWalls.
Starting point is x1, y1, ending point is x2, y2. 
See [createWalls|Lua-simulation#createWalls].

!!! Defaults

x1, y1, x2, y2 = -1 {br} rx, ry = 0 {br} walltype = 8 (block wall) 

!! createWallBox

{{int sim.createWallBox (int x1, int y1, int x2, int y2, int walltype)}}
Creates a filled box with a wall, from top-left point x1,y1 to bottom-right point x2, y2. 
See [createWalls|Lua-simulation#createWalls]. 

!!! Defaults

x1, y1, x2, y2 = -1 {br} walltype = 8 (block wall) 

!! floodWalls

{{int sim.floodWalls (int x, int y, int walltype, int bm)}}
Flood-fills walls, starting from a point.

!!! Defaults
x, y = -1 {br} walltype = 8 (block wall) {br} bm = -1 

!! toolBrush

{{int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush)
int sim.toolBrush (int x, int y, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.

!! Defaults
x, y = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolLine

{{int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush)
int sim.toolLine (int x1, int y1, int x2, int y2, int rx, int ry, int tool, int brush, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius, with a strength.
See [toolBrush|Lua-simulation#toolBrush]. 


!! Defaults
x1, x2, y1, y2 = -1 {br} rx, ry = 5 {br} tool = 0 {br} brush = CIRCLE_BRUSH {br} strength = 1.0

!! toolBox

{{int sim.toolBox (int x1, int x2, int y1, int y2, int tool, float strength)}}
Applies a tool to a position with a brush with horizontal and vertical radius.
See [toolBrush|Lua-simulation#toolBrush]. 


!! decoBrush

{{int sim.decoBrush (int x, int y, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draws decorations onto a position with center at x, y, vertical and horizontalr radius,
separate color components and alpha component, the decoration tool type, and the [brush type|Brush#_Types].

Decoration tool types are: 
{{#define DECO_DRAW 0 // regular drawing
#define DECO_ADD  1 // add blend
#define DECO_SUBTRACT 2 // subtract blend
#define DECO_MULTIPLY 3 // multiply blend (original color * new color) % 255
#define DECO_DIVIDE 4 // divide blend 
#define DECO_SMUDGE 5 // blur colors
#define DECO_CLEAR  6 // remove colors}}

!!! Defaults
x, y = -1 {br} rx, ry = 5 {br} r, g, b, a = 255 {br} tool = DECO_DRAW {br} brush = CIRCLE_BRUSH

!! decoLine

{{int sim.decoLine (int x1, int y1, int x2, int y2, int rx, int ry, int r, int g, int b, int a, int tool, int brush)}}
Draw a line of decorations with decoBrush.
See [decoBrush|Lua-simulation#decoBrush]. 


!! decoBox
{{int sim.decoBox(int x1, int y1, int x2, int y2, int r, int g, int b, int a, int tool)}}
Draw a box with decoBrush, using an 1x1 brush.
See [decoBrush|Lua-simulation#decoBrush]. 

!! decoColor
{{int sim.decoColor()
nil sim.decoColor(int r, int g, int b, int a)}}
Set the currently selected decoration color. Doesn't apply to deco drawing methods, they use the color they're passed.

!!! Defaults

r, g, b, a = 255


!! clearSim
{{nil clearSim ()}}
Clear the Simulation of all particles.

!! resetTemp
{{nil sim.resetTemp (boolint onlyConductors)}}
Resets the temperature of everything to what their [element property|Element properties#__Temperature] says. Optionally, only resets conductive elements. 

!!! Defaults
onlyConductors = 0

!! resetPressure
{{nil sim.resetPressure(int x, int y, int width, int height)}}
Resets the pressure at a given area. Defaults to the entire stage.

!!! Defaults
x, y = 0 {br} width = XRES/CELL {br} height = YRES/CELL

!! saveStamp
{{string sim.saveStamp(int x, int y, int width, int height)}}
Saves an area of the game to a stamp, and returns its name.

!!! Defaults
x, y = 0 {br} width = XRES - 1 {br} height = YRES - 1

!! loadStamp
{{int sim.loadStamp (string stampFile, int x, int y)
int sim.loadStamp (string fullPathToStamp, int x, int y)
int sim.loadStamp (int stampID, int x, int y)}}
Loads a stamp on screen. The stamp can be referred to by either its 10-character name, by its full path or by its stamp ID. 

!!! Defaults
x, y = 0

!! deleteStamp
{{int sim.deleteStamp (string stampFile)
int sim.deleteStamp (int stampID)}}
Delete a stamp file by its stamp ID or by its 10-character filename, or by its full path.

!! loadSave
{{int sim.loadSave (int saveID, boolint instant, int timestamp)}}
Load a save by its save ID and ''exact'' historical timestamp.
Set instant to 1 to load the save instantly, or something.

!! getSaveID
{{int sim.getSaveID ()}}
Get this save's save ID, or return nil if there is none.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;</ins>

</pre></description>
	</item>

	<item>
	  <title>Brush</title>
	  <pubDate>Thu, 03 Jul 2014 16:28:53 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Brush</link>
	  <description><pre id="diff"><ins>This page is all about the lovely brush, or the mouse, or whatever you want to call it. It groups together things you need to know when using the [createParts|sim#_createParts] functions. 

! Types

Brushes have types. You can try it out by pressing Tab in-game. There's an ellipse, a rectangle and an (isosceles) triangle.

{{#define CIRCLE_BRUSH 0 // Ellipse
#define SQUARE_BRUSH 1 // Rectangle
#define TRI_BRUSH 2 // Triangle
#define BRUSH_NUM 3 // How many brushes do we have?}}

! Flags

Sometimes the simulation is set up to have different modes enabled, like Replace mode or Specific Delete mode. Those are kept inside the sim-&gt;replaceModeFlags variable, and brush-using functions default to that current setting.

{{#define REPLACE_MODE 0x1 //replace mode / specific delete flags
#define SPECIFIC_DELETE 0x2}}</ins>
</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 16:19:16 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

! Methods

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.


!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil partKill (int index)
nil partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float pressure (int x, int y)
nil pressure (int x, int y, float value)
nil pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float ambientHeat (int x, int y)
nil ambientHeat (int x, int y, float value)
nil ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float velocityX (int x, int y)
nil velocityX (int x, int y, float value)
nil velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float velocityY (int x, int y)
nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int createParts (int centerx, int centery, int radiusx, int radiusy, <del>[element|Definitions#_Element]</del><ins>element</ins> type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
{.hl}centerx{/}, {.hl}centery{/} define the center point of the brush, {br} {.hl}radiusx{/}, {.hl}radiusy{/} define the radiuses on the X and Y axes, {br} {.hl}type{/} is the [element|Definitions#_Element] type we're using, {br} {.hl}brush{/} is the [brush type|Brush#_Types], and {br} {.hl}flags{/} are the [brush flags|Brush#_Flags] we need to use.

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 16:18:52 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

! Methods

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.


!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by [GOL elements|List of GOL types] to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil partKill (int index)
nil partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float pressure (int x, int y)
nil pressure (int x, int y, float value)
nil pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float ambientHeat (int x, int y)
nil ambientHeat (int x, int y, float value)
nil ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float velocityX (int x, int y)
nil velocityX (int x, int y, float value)
nil velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float velocityY (int x, int y)
nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int createParts (int centerx, int centery, int radiusx, int radiusy, [element|Definitions#_Element] type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
<del>centerx, centery</del><ins>{.hl}centerx{/}, {.hl}centery{/}</ins> define the center point of the brush, {br} <del>radiusx, radiusy</del><ins>{.hl}radiusx{/}, {.hl}radiusy{/}</ins> define the radiuses on the X and Y axes, {br} <del>type</del><ins>{.hl}type{/}</ins> is the [element|Definitions#_Element] type we're using, {br} <del>brush</del><ins>{.hl}brush{/}</ins> is the [brush type|Brush#_Types], and {br} <del>flags</del><ins>{.hl}flags{/}</ins> are the [brush flags|Brush#_Flags] we need to use.

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 16:17:22 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

! Methods

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.


!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of {.hl}(x,y){/}.

{.hl}type_and_var{/} is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the {.hl}type_and_var{/} into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by<ins> [GOL elements|List of</ins> GOL <del>elements</del><ins>types]</ins> to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set {.hl}newindex{/} to -1 to use the first available index and create a new particle.
Set {.hl}newindex{/} to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set {.hl}newindex{/} to -3 to 'skip pmap checks'. 
Otherwise, set {.hl}newindex{/} to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}


!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil partKill (int index)
nil partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float pressure (int x, int y)
nil pressure (int x, int y, float value)
nil pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float ambientHeat (int x, int y)
nil ambientHeat (int x, int y, float value)
nil ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float velocityX (int x, int y)
nil velocityX (int x, int y, float value)
nil velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float velocityY (int x, int y)
nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int createParts (int centerx, int centery, int radiusx, int radiusy, [element|Definitions#_Element] type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
centerx, centery define the center point of the brush, {br} radiusx, radiusy define the radiuses on the X and Y axes, {br} type is the [element|Definitions#_Element] type we're using, {br} brush is the [brush type|Brush#_Types], and {br} flags are the [brush flags|Brush#_Flags] we need to use.

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 16:16:02 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

! Methods

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table sim.partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.


!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of <del>(x,y).</del><ins>{.hl}(x,y){/}.</ins>

<del>type_and_var</del><ins>{.hl}type_and_var{/}</ins> is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the <del>type_and_var</del><ins>{.hl}type_and_var{/}</ins> into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by GOL elements to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set <del>newindex</del><ins>{.hl}newindex{/}</ins> to -1 to use the first available index and create a new particle.
Set <del>newindex</del><ins>{.hl}newindex{/}</ins> to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set <del>newindex</del><ins>{.hl}newindex{/}</ins> to -3 to 'skip pmap checks'. 
Otherwise, set <del>newindex</del><ins>{.hl}newindex{/}</ins> to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}
<ins></ins>

!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil partKill (int index)
nil partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float pressure (int x, int y)
nil pressure (int x, int y, float value)
nil pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float ambientHeat (int x, int y)
nil ambientHeat (int x, int y, float value)
nil ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float velocityX (int x, int y)
nil velocityX (int x, int y, float value)
nil velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float velocityY (int x, int y)
nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int createParts (int centerx, int centery, int radiusx, int radiusy, [element|Definitions#_Element] type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
centerx, centery define the center point of the brush, {br} radiusx, radiusy define the radiuses on the X and Y axes, {br} type is the [element|Definitions#_Element] type we're using, {br} brush is the [brush type|Brush#_Types], and {br} flags are the [brush flags|Brush#_Flags] we need to use.

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 16:13:58 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

! Methods

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table <del> partNeighbours</del><ins>sim.partNeighbours</ins> (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.
<ins></ins>

!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of (x,y).

type_and_var is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the type_and_var into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by GOL elements to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set newindex to -1 to use the first available index and create a new particle.
Set newindex to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set newindex to -3 to 'skip pmap checks'. 
Otherwise, set newindex to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}

!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil partKill (int index)
nil partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float pressure (int x, int y)
nil pressure (int x, int y, float value)
nil pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float ambientHeat (int x, int y)
nil ambientHeat (int x, int y, float value)
nil ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float velocityX (int x, int y)
nil velocityX (int x, int y, float value)
nil velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float velocityY (int x, int y)
nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int createParts (int centerx, int centery, int radiusx, int radiusy, [element|Definitions#_Element] type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
centerx, centery define the center point of the brush, {br} radiusx, radiusy define the radiuses on the X and Y axes, {br} type is the [element|Definitions#_Element] type we're using, {br} brush is the [brush type|Brush#_Types], and {br} flags are the [brush flags|Brush#_Flags] we need to use.

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 16:13:32 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff">It's the simulation object! You can call me {.hl-1}sim{/} though.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;
<ins>
! Methods</ins>

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table  partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.

!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of (x,y).

type_and_var is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the type_and_var into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by GOL elements to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set newindex to -1 to use the first available index and create a new particle.
Set newindex to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set newindex to -3 to 'skip pmap checks'. 
Otherwise, set newindex to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}

!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil partKill (int index)
nil partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float pressure (int x, int y)
nil pressure (int x, int y, float value)
nil pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float ambientHeat (int x, int y)
nil ambientHeat (int x, int y, float value)
nil ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float velocityX (int x, int y)
nil velocityX (int x, int y, float value)
nil velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float velocityY (int x, int y)
nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int createParts (int centerx, int centery, int radiusx, int radiusy, [element|Definitions#_Element] type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
centerx, centery define the center point of the brush, {br} radiusx, radiusy define the radiuses on the X and Y axes, {br} type is the [element|Definitions#_Element] type we're using, {br} brush is the [brush type|Brush#_Types], and {br} flags are the [brush flags|Brush#_Flags] we need to use.

</pre></description>
	</item>

	<item>
	  <title>Lua-simulation</title>
	  <pubDate>Thu, 03 Jul 2014 16:13:14 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-simulation</link>
	  <description><pre id="diff"><ins>It's the simulation object! You can call me {.hl-1}sim{/} though.

! Field constants

You can use field constants instead of the equivalent strings, as field constants are integers and thus compare way faster than two strings do. 

!! FIELD_CTYPE 
Equivalent with the string: &quot;[ctype|Particle properties#_ctype]&quot;

!! FIELD_DCOLOUR 
Equivalent with the string: &quot;[dcolour|Particle properties#_dcolour]&quot;

!! FIELD_FLAGS 
Equivalent with the string: &quot;[flags|Particle properties#_flags]&quot;

!! FIELD_LIFE 
Equivalent with the string: &quot;[life|Particle properties#_life]&quot;

!! FIELD_TEMP 
Equivalent with the string: &quot;[temp|Particle properties#_temp]&quot;

!! FIELD_TMP 
Equivalent with the string: &quot;[tmp|Particle properties#_tmp]&quot;

!! FIELD_TMP2 
Equivalent with the string: &quot;[tmp2|Particle properties#_tmp2]&quot;

!! FIELD_TYPE 
Equivalent with the string: &quot;[type|Particle properties#_type]&quot;

!! FIELD_VX 
Equivalent with the string: &quot;[vx|Particle properties#_vx]&quot;

!! FIELD_VY 
Equivalent with the string: &quot;[vy|Particle properties#_vy]&quot;

!! FIELD_X 
Equivalent with the string: &quot;[x|Particle properties#_x]&quot;

!! FIELD_Y 
Equivalent with the string: &quot;[y|Particle properties#_y]&quot;

!! partNeighbours
{{table sim.partNeighbours (int x, int y, int radius)
table  partNeighbours (int x, int y, int radius, int type)}}
Returns a table of particles around the center position of (x, y) with your given radius. If you pass an element type, it also filters by type. Instead of ''Neighbours'' you can use ''Neighbors''.

!! partChangeType

{{nil sim.partChangeType (int index, int type)}}
Change a particle's type to the passed type. There's probably some other magic involved, like creation temperatures, so it's better than setting the particle's .type.

!! partCreate

{{int sim.partCreate (int newindex, int x, int y, int type_and_var)}}
Creates a particle into a position of (x,y).

type_and_var is a compound variable which you can just set to your type if you don't want anything to do with the var part. Some elements, however, also use the var part of type_and_var. Then you can split up the type_and_var into a type and var part like this: 
{{int type = type_and_var &amp;amp; 0xFF;
int var = (type_and_var &gt;&gt; 8) &amp;amp; 0xFFFFFF;}}

For example, var is used by GOL elements to specify which GOL element they are, and when you're setting CRAY's ctype to GOL elements, it secretly copies over the GOL element type too to its tmp2. 

Set newindex to -1 to use the first available index and create a new particle.
Set newindex to -2 to make your particle creation seem like it was from a brush (like the mouse). This lets you, for example, emulate how users set CLNE ctypes with the brush. 
Set newindex to -3 to 'skip pmap checks'. 
Otherwise, set newindex to any existing index to replace that index with the new particle.

!!! Examples

Create a particle at 100,100 with type DUST: 
{{sim.partCreate(-1, 100, 100, elements.DEFAULT_PT_DUST)}}

Create a particle at 100,100 with type LIFE(BRAN), or life type #23
{{sim.partCreate(-1, 100, 100, bit.bor(bit.lshift(23, 8), elements.DEFAULT_PT_LIFE))}}

!! partProperty

{{mixed sim.partProperty(int index, string field)
nil sim.partProperty(int index, string field, mixed value)}}

Gets and sets [particle properties]. 

!! partPosition

{{int, int partPosition (int index)}}
Returns x, y from a particle index.

!! partID

{{int partID (int x, int y)}}
Returns particle index from x, y. If multiple particles are stacked, returns the index of the topmost particle.

!! partKill

{{nil partKill (int index)
nil partKill (int x, int y)}}
Delete and dispose of a particle. 

!! pressure

{{float pressure (int x, int y)
nil pressure (int x, int y, float value)
nil pressure (int x, int y, int width, int height, float value)}}
Get and set pressure at the position in wall coordinates.
Also, set pressure at a rectangle in wall coordinates to value. 

!! ambientHeat

{{float ambientHeat (int x, int y)
nil ambientHeat (int x, int y, float value)
nil ambientHeat (int x, int y, int width, int height, float value)}}
Get and set ambient heat at the position in wall coordinates. 
Also, set ambient heat at a rectangle in wall coordinates to value. 

!! velocityX

{{float velocityX (int x, int y)
nil velocityX (int x, int y, float value)
nil velocityX (int x, int y, int width, int height, float value)}}
Get and set velocity (of the X axis) at the position in wall coordinates. 
Also, set velocity (of the X axis) at a rectangle in wall coordinates to value. 

!! velocityY

{{float velocityY (int x, int y)
nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Get and set velocity (of the Y axis) at the position in wall coordinates. 
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! gravMap

{{nil velocityY (int x, int y, float value)
nil velocityY (int x, int y, int width, int height, float value)}}
Set the gravity map value at the position in wall coordinates to value.
Also, set velocity (of the Y axis) at a rectangle in wall coordinates to value. 

!! createParts

{{int createParts (int centerx, int centery, int radiusx, int radiusy, [element|Definitions#_Element] type, int brush, int flags)}}
Create particles like a brush (the mouse) would. 
centerx, centery define the center point of the brush, {br} radiusx, radiusy define the radiuses on the X and Y axes, {br} type is the [element|Definitions#_Element] type we're using, {br} brush is the [brush type|Brush#_Types], and {br} flags are the [brush flags|Brush#_Flags] we need to use.
</ins>
</pre></description>
	</item>

	<item>
	  <title>sim</title>
	  <pubDate>Thu, 03 Jul 2014 16:12:59 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=sim</link>
	  <description><pre id="diff"><ins>{redirect:Lua-simulation}</ins>
</pre></description>
	</item>

	<item>
	  <title>Definitions</title>
	  <pubDate>Thu, 03 Jul 2014 15:31:20 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Definitions</link>
	  <description><pre id="diff">Here I'll formally define some of the words I'll be using throughout the wiki.

!! Particle

A particle is one of those pixel things you see on screen. For example, you can have 5 particles of the [element] dust on the screen, or two particles of photon on screen. It has its own [properties|Particle properties] which are unique to each particle, for example its x and y coordinates, life, type, ...

!! Element

An element is a certain type of [particle]. For example, water or dust or oil or coal. It has its own [properties|Element properties] (for example, starting temperature), which also include the update and graphics functions that get run once for each particle of this element type.
<ins>
As an argument type, element could either mean: 
# An integer representing the [element ID|Element IDs]
# A string representing the element [Name|Element properties#__Name]
# A string representing the element [Identifier|Element properties#__Identifier]
Some functions take one of those types, some take more than one, some take only the element ID. If you don't know which to use, use the element ID, or convert the other two types into the element ID using [tpt.element|tpt#_element]

!! Field

A field is the name of a particle or element property, represented either as a string, or an integer in some cases. 

For example, the [sim] object contains constants akin to FIELD_X. 
</ins>

</pre></description>
	</item>

	<item>
	  <title>List of GOL types</title>
	  <pubDate>Thu, 03 Jul 2014 15:21:34 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=List+of+GOL+types</link>
	  <description><pre id="diff">This page lists all of the Game of Life types in this game, in two lists. There's an old ID and a new ID. 
(Up to date as of [c4dcb37de40eda86871ba4e0992877528a208e39|https://github.com/simtr/The-Powder-Toy/blob/c4dcb37de40eda86871ba4e0992877528a208e39/src/simulation/SimulationData.h#L72-L122])
<del>{{//Old</del><ins>{{
#define GT_GOL 78  //Old</ins> IDs for GOL types<del>
#define GT_GOL 78</del>
#define GT_HLIF 79
#define GT_ASIM 80
#define GT_2x2 81
#define GT_DANI 82
#define GT_AMOE 83
#define GT_MOVE 84
#define GT_PGOL 85
#define GT_DMOE 86
#define GT_34 87
#define GT_LLIF 88
#define GT_STAN 89
#define GT_SEED 134
#define GT_MAZE 135
#define GT_COAG 136
#define GT_WALL 137
#define GT_GNAR 138
#define GT_REPL 139
#define GT_MYST 140
#define GT_LOTE 142
#define GT_FRG2 143
#define GT_STAR 144
#define GT_FROG 145
#define GT_BRAN 146

<del>//New</del><ins>#define NGT_GOL 0  //New</ins> IDs for GOL types<del>
#define NGT_GOL 0</del>
#define NGT_HLIF 1
#define NGT_ASIM 2
#define NGT_2x2 3
#define NGT_DANI 4
#define NGT_AMOE 5
#define NGT_MOVE 6
#define NGT_PGOL 7
#define NGT_DMOE 8
#define NGT_34 9
#define NGT_LLIF 10
#define NGT_STAN 11
#define NGT_SEED 12
#define NGT_MAZE 13
#define NGT_COAG 14
#define NGT_WALL 15
#define NGT_GNAR 16
#define NGT_REPL 17
#define NGT_MYST 18
#define NGT_LOTE 19
#define NGT_FRG2 20
#define NGT_STAR 21
#define NGT_FROG 22
#define NGT_BRAN 23}}


!! NGT_GOL 
Value: 0
Life type name: Conway's Game of Life
Definition string: Born 3 / Survive 2, 3

!! NGT_HLIF 
Value: 1
Life type name: High Life
Definition string: Born 3, 6 / Survive 2, 3

!! NGT_ASIM 
Value: 2
Life type name: Assimilation
Definition string: Born 3, 4, 5 / Survive 4, 5, 6, 7

!! NGT_2x2 
Value: 3
Life type name: 2x2
Definition string: Born 3, 6 / Survive 1, 2, 5

!! NGT_DANI 
Value: 4
Life type name: Day/Night
Definition string: Born 3, 6, 7, 8 / Survive 3, 4, 6, 7, 8

!! NGT_AMOE 
Value: 5
Life type name: Amoeba
Definition string: Born 3, 5, 7 / Survive 1, 3, 5, 8

!! NGT_MOVE 
Value: 6
Life type name: MOVE
Definition string: Born 3, 6, 8 / Survive 2, 4, 5

!! NGT_PGOL 
Value: 7
Life type name: Pseudo-Life
Definition string: Born 3, 5, 7 / Survive 2, 3, 8

!! NGT_DMOE 
Value: 8
Life type name: Di-amoeba
Definition string: Born 3, 5, 6, 7, 8 / Survive 5, 6, 7, 8

!! NGT_34 
Value: 9
Life type name: 3/4
Definition string: Born 3, 4 / Survive 3, 4

!! NGT_LLIF 
Value: 10
Life type name: Long Life
Definition string: Born 3, 4, 5 / Survive 5&amp;lt;

!! NGT_STAN 
Value: 11
Life type name: Stains
Definition string: Born 3, 6, 8 / Survive 2, 3, 5, 6, 7, 8

!! NGT_SEED 
Value: 12
Life type name: Seeds
Definition string: Born 2 / Survive -

!! NGT_MAZE 
Value: 13
Life type name: Mazes
Definition string: Born 3 / Survive 1, 2, 3, 4, 5

!! NGT_COAG 
Value: 14
Life type name: Coagulations
Definition string: Born 3, 7, 8 / Survive 2, 3, 5, 6, 7, 8

!! NGT_WALL 
Value: 15
Life type name: Walled Cities
Definition string: Born 4, 5, 6, 7, 8 / Survive 2, 3, 4, 5 

!! NGT_GNAR 
Value: 16
Life type name: Gnarl
Definition string: Born 1 / Survive 1

!! NGT_REPL 
Value: 17
Life type name: Replicator
Definition string: Born 1, 3, 5, 7 / Survive 1, 3, 5, 7

!! NGT_MYST 
Value: 18
Life type name: Mystery
Definition string: Born 3, 4, 5, 8 / Survive 0, 5, 6, 7, 8 

!! NGT_LOTE 
Value: 19
Life type name: Life on the Edge
Definition string: Born 3, 7 / Survive 3, 4, 5, 8 / Death Delay 4

!! NGT_FRG2 
Value: 20
Life type name: Frog #2
Definition string: Born 3 / Survive 1, 2, 4 / Death Delay 3

!! NGT_STAR 
Value: 21
Life type name: Star Wars? 
Definition string: Born 2, 7, 8 / Survive 3, 4, 5, 6 / Death Delay 6

!! NGT_FROG 
Value: 22
Life type name: Frogs
Definition string: Born 3, 4 / Survive 1, 2, 4 / Death Delay 3

!! NGT_BRAN 
Value: 23
Life type name: Brian
Definition string: Born 2, 4, 6 / Survive 6 / Death Delay 3
</pre></description>
	</item>

	<item>
	  <title>List of GOL types</title>
	  <pubDate>Thu, 03 Jul 2014 15:21:06 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=List+of+GOL+types</link>
	  <description><pre id="diff"><ins>This page lists all of the Game of Life types in this game, in two lists. There's an old ID and a new ID. 
(Up to date as of [c4dcb37de40eda86871ba4e0992877528a208e39|https://github.com/simtr/The-Powder-Toy/blob/c4dcb37de40eda86871ba4e0992877528a208e39/src/simulation/SimulationData.h#L72-L122])
{{//Old IDs for GOL types
#define GT_GOL 78
#define GT_HLIF 79
#define GT_ASIM 80
#define GT_2x2 81
#define GT_DANI 82
#define GT_AMOE 83
#define GT_MOVE 84
#define GT_PGOL 85
#define GT_DMOE 86
#define GT_34 87
#define GT_LLIF 88
#define GT_STAN 89
#define GT_SEED 134
#define GT_MAZE 135
#define GT_COAG 136
#define GT_WALL 137
#define GT_GNAR 138
#define GT_REPL 139
#define GT_MYST 140
#define GT_LOTE 142
#define GT_FRG2 143
#define GT_STAR 144
#define GT_FROG 145
#define GT_BRAN 146

//New IDs for GOL types
#define NGT_GOL 0
#define NGT_HLIF 1
#define NGT_ASIM 2
#define NGT_2x2 3
#define NGT_DANI 4
#define NGT_AMOE 5
#define NGT_MOVE 6
#define NGT_PGOL 7
#define NGT_DMOE 8
#define NGT_34 9
#define NGT_LLIF 10
#define NGT_STAN 11
#define NGT_SEED 12
#define NGT_MAZE 13
#define NGT_COAG 14
#define NGT_WALL 15
#define NGT_GNAR 16
#define NGT_REPL 17
#define NGT_MYST 18
#define NGT_LOTE 19
#define NGT_FRG2 20
#define NGT_STAR 21
#define NGT_FROG 22
#define NGT_BRAN 23}}


!! NGT_GOL 
Value: 0
Life type name: Conway's Game of Life
Definition string: Born 3 / Survive 2, 3

!! NGT_HLIF 
Value: 1
Life type name: High Life
Definition string: Born 3, 6 / Survive 2, 3

!! NGT_ASIM 
Value: 2
Life type name: Assimilation
Definition string: Born 3, 4, 5 / Survive 4, 5, 6, 7

!! NGT_2x2 
Value: 3
Life type name: 2x2
Definition string: Born 3, 6 / Survive 1, 2, 5

!! NGT_DANI 
Value: 4
Life type name: Day/Night
Definition string: Born 3, 6, 7, 8 / Survive 3, 4, 6, 7, 8

!! NGT_AMOE 
Value: 5
Life type name: Amoeba
Definition string: Born 3, 5, 7 / Survive 1, 3, 5, 8

!! NGT_MOVE 
Value: 6
Life type name: MOVE
Definition string: Born 3, 6, 8 / Survive 2, 4, 5

!! NGT_PGOL 
Value: 7
Life type name: Pseudo-Life
Definition string: Born 3, 5, 7 / Survive 2, 3, 8

!! NGT_DMOE 
Value: 8
Life type name: Di-amoeba
Definition string: Born 3, 5, 6, 7, 8 / Survive 5, 6, 7, 8

!! NGT_34 
Value: 9
Life type name: 3/4
Definition string: Born 3, 4 / Survive 3, 4

!! NGT_LLIF 
Value: 10
Life type name: Long Life
Definition string: Born 3, 4, 5 / Survive 5&amp;lt;

!! NGT_STAN 
Value: 11
Life type name: Stains
Definition string: Born 3, 6, 8 / Survive 2, 3, 5, 6, 7, 8

!! NGT_SEED 
Value: 12
Life type name: Seeds
Definition string: Born 2 / Survive -

!! NGT_MAZE 
Value: 13
Life type name: Mazes
Definition string: Born 3 / Survive 1, 2, 3, 4, 5

!! NGT_COAG 
Value: 14
Life type name: Coagulations
Definition string: Born 3, 7, 8 / Survive 2, 3, 5, 6, 7, 8

!! NGT_WALL 
Value: 15
Life type name: Walled Cities
Definition string: Born 4, 5, 6, 7, 8 / Survive 2, 3, 4, 5 

!! NGT_GNAR 
Value: 16
Life type name: Gnarl
Definition string: Born 1 / Survive 1

!! NGT_REPL 
Value: 17
Life type name: Replicator
Definition string: Born 1, 3, 5, 7 / Survive 1, 3, 5, 7

!! NGT_MYST 
Value: 18
Life type name: Mystery
Definition string: Born 3, 4, 5, 8 / Survive 0, 5, 6, 7, 8 

!! NGT_LOTE 
Value: 19
Life type name: Life on the Edge
Definition string: Born 3, 7 / Survive 3, 4, 5, 8 / Death Delay 4

!! NGT_FRG2 
Value: 20
Life type name: Frog #2
Definition string: Born 3 / Survive 1, 2, 4 / Death Delay 3

!! NGT_STAR 
Value: 21
Life type name: Star Wars? 
Definition string: Born 2, 7, 8 / Survive 3, 4, 5, 6 / Death Delay 6

!! NGT_FROG 
Value: 22
Life type name: Frogs
Definition string: Born 3, 4 / Survive 1, 2, 4 / Death Delay 3

!! NGT_BRAN 
Value: 23
Life type name: Brian
Definition string: Born 2, 4, 6 / Survive 6 / Death Delay 3</ins>
</pre></description>
	</item>

	<item>
	  <title>elem</title>
	  <pubDate>Thu, 03 Jul 2014 14:26:37 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=elem</link>
	  <description><pre id="diff"><ins>{redirect:Lua-elements}</ins>
</pre></description>
	</item>

	<item>
	  <title>Main page</title>
	  <pubDate>Thu, 03 Jul 2014 14:26:19 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Main+page</link>
	  <description><pre id="diff">This is a sort of wiki for TPTElements. It's meant to gather all this data together and link it in a meaningful way. I do not intend to make this wiki publicly editable, however this might happen someday.

Its secondary purpose is to reduce the cruft in the Lua reference, and allow me to comfortably link articles and knowledge together. 

This also means I'll start moving out descriptions of functions from the reference into this wiki thing.

----

Here's some example links to get you started:

* [Element properties]
* [Particle properties]
* [Function signatures]
* [Definitions]
* [Element IDs]
<ins>* [elem]
* [sim]
* [tpt]
* [Menu sections]</ins>

----

In this wiki I'll sometimes (often, even) show examples in the programming language [C++|http://en.wikipedia.org/wiki/C%2B%2B], and sometimes in the programming language [Lua|http://en.wikipedia.org/wiki/Lua_(programming_language)]. Those are necessary to talk about programming freely and to show examples about what you can and can not do in TPT. As an example, see these scripts below. 

{{function key (keys, keyn, mod, evt) 
  lastmod = mod
  if evt == 1 then
    -- pressed
    lastkeyn = keyn
    pressing = true
  elseif evt == 2 then
    -- released
    lastkeyn = keyn
    pressing = false
  end
end}}

{{    // arrow up
    if (Element_KSNS::arrows &amp; 0x01) {
      // walk two particles to the direction and turn into spark first thing
      r = pmap[y-1][x];
      // why can't i just short-circuited-OR the two
      if (!r)
        r = pmap[y-2][x];
      
      if (!r) 
        return 0;}}

{tags:MainPage}
</pre></description>
	</item>

	<item>
	  <title>Main page</title>
	  <pubDate>Thu, 03 Jul 2014 14:25:09 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Main+page</link>
	  <description><pre id="diff">This is a sort of wiki for TPTElements. It's meant to gather all this data together and link it in a meaningful way. I do not intend to make this wiki publicly editable, however this might happen someday.
<ins>
Its secondary purpose is to reduce the cruft in the Lua reference, and allow me to comfortably link articles and knowledge together. </ins>

This also means I'll start moving out descriptions of functions from the reference into this wiki thing.

----

Here's some example links to get you started:

* [Element properties]
* [Particle properties]
* [Function signatures]
* [Definitions]
* [Element IDs]

----

In this wiki I'll sometimes (often, even) show examples in the programming language [C++|http://en.wikipedia.org/wiki/C%2B%2B], and sometimes in the programming language [Lua|http://en.wikipedia.org/wiki/Lua_(programming_language)]. Those are necessary to talk about programming freely and to show examples about what you can and can not do in TPT. As an example, see these scripts below. 

{{function key (keys, keyn, mod, evt) 
  lastmod = mod
  if evt == 1 then
    -- pressed
    lastkeyn = keyn
    pressing = true
  elseif evt == 2 then
    -- released
    lastkeyn = keyn
    pressing = false
  end
end}}

{{    // arrow up
    if (Element_KSNS::arrows &amp; 0x01) {
      // walk two particles to the direction and turn into spark first thing
      r = pmap[y-1][x];
      // why can't i just short-circuited-OR the two
      if (!r)
        r = pmap[y-2][x];
      
      if (!r) 
        return 0;}}

{tags:MainPage}
</pre></description>
	</item>

	<item>
	  <title>Menu sections</title>
	  <pubDate>Thu, 03 Jul 2014 14:22:33 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Menu+sections</link>
	  <description><pre id="diff"><ins>Menu sections are the following: 

{html}&amp;lt;img src=&quot;static/menusections.png&quot; /&gt;{/html}

!! SC_WALL
Value: 0
Section title: Walls

!! SC_ELEC
Value: 1
Section title: Electronics

!! SC_POWERED
Value: 2
Section title: Powered Materials

!! SC_SENSOR
Value: 3
Section title: Sensors

!! SC_FORCE
Value: 4
Section title: Force

!! SC_EXPLOSIVE
Value: 5
Section title: Explosives

!! SC_GAS
Value: 6
Section title: Gasses

!! SC_LIQUID
Value: 7
Section title: Liquids

!! SC_POWDERS
Value: 8
Section title: Powders

!! SC_SOLIDS
Value: 9
Section title: Solids

!! SC_NUCLEAR
Value: 10
Section title: Radioactive

!! SC_SPECIAL
Value: 11
Section title: Special

!! SC_LIFE
Value: 12
Section title: Game of Life

!! SC_TOOL
Value: 13
Section title: Tools

!! SC_DECO
Value: 14
Section title: Decoration tools
</ins>
</pre></description>
	</item>

	<item>
	  <title>Lua-elements</title>
	  <pubDate>Thu, 03 Jul 2014 14:04:58 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Lua-elements</link>
	  <description><pre id="diff"><ins>''This is the page about the Lua ''elements'' table.''

The elements table contains functions and properties you can use while modifying, adding and removing elements, plus a few interesting constants. You can alternatively refer to it as {.hl-1}elem{/}. 

See {html}&amp;lt;a href=&quot;../lua-reference.html#elements&quot;&gt;the Lua reference&amp;lt;/a&gt;{/html} for a quick overview of the table.

! Particle movement

!! TYPE_PART
Value: 0x00001
Moves like a particle.

!! TYPE_LIQUID
Value: 0x00002
Moves like a liquid.

!! TYPE_SOLID
Value: 0x00004
Moves like a solid. (not at all!)

!! TYPE_GAS
Value: 0x00008
Moves like a gas.

!! TYPE_ENERGY
Value: 0x00010
Moves like an energy particle. (varies)

! Particle properties

( see [Properties] )

! .flags values

!! FLAG_STAGNANT
Value: 1 
Update a bit less than usually

!! FLAG_SKIPMOVE
Value: 2 
Don't do movement checks

!! FLAG_MOVABLE
Value: 8 

! [State|Element properties#__State] values

!! ST_NONE
Value: 0
No defined state

!! ST_SOLID
Value: 1
It's a solid!

!! ST_LIQUID
Value: 2
It's a liquid!

!! ST_GAS
Value: 3
It's a gas!

! Menu sections

( see [Menu sections] )

! Element IDs

When you create an element, its ID gets added here for later access, when you don't have it stored to a variable. Element IDs have a name and namespace, which together form the [Identifier|Element properties#__Identifier]. 
All default elements are in the aptly-named namespace &quot;DEFAULT&quot;, and their identifiers are DEFAULT_PT_&amp;lt;element name&gt;. 
For example, DUST is DEFAULT_PT_DUST. 
If you make your own element, it's wise to use your own username or something unique as the namespace, so if I made an element called ELEM, its Identifier would be BOXMEIN_PT_ELEM. 

! allocate

{{int elem.allocate (string namespace, string name);}}

Sets up a space for a new element. Returns the newly minted element ID. Creates a new entry under elements with the Identifier &amp;lt;namespace&gt;_PT_&amp;lt;name&gt;.
You can then operate on this element ID later, and create your own element without modifying other peoples' elements.

! free

{{nil elem.free (int elementID)}}

Deletes an element. You don't have to manually do this aside from when you want to remove an element. 

! loadDefault

{{table elem.loadDefault ()
table elem.loadDefault(int elementID}}

Deletes/resets the element with the ID you specified.
When you don't pass any element ID, it restores all default elements to their unmodified state, and deletes all custom elements. Returns a table with (to be written).

! element

{{table elem.element (int elementID)
nil elem.element (int elementID, table values)}}

Gets a table of every [element property|Element properties], with the key being the property and the value being the property's value. 
Sets an element's every property to the values in the given table, where the key is the property and the value is the property's value.
You can use it with itself to &quot;duplicate&quot; every property of an element and re-assign it to another element in one line. For example, this code sets every property of the element with ID elementID into water's equivalent properties.

{{elem.element(elementID, elem.element(elem.DEFAULT_PT_WATR))}}

You can also modify the table before assigning, meaning you don't have to use as many [elem.property|Lua-elements#_property] calls.

{{local t = elem.element(elem.DEFAULT_PT_WATR))
t[&quot;Colour&quot;] = 0xFF252525
t[&quot;Weight&quot;] = 25
elem.element(myElementID, t)}}

! property

{{mixed elem.property (int elementID, string property)
nil elem.property (int elementID, string property, mixed value)}}
Depending on whether you pass a third argument, gets or sets an [element property|Element properties]. ˇ

As an example, this turns water green:

{{elem.property(elements.DEFAULT_PT_WATR, &quot;Colour&quot;, 0xFF00FF00)}}
</ins>
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 13:05:58 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior. {br} 1 = Explodes with fire. {br} 2 = Explodes with &gt;2.5 pressure as well as fire.


!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = <del>gasses.
    2</del><ins>gasses.{br}    2</ins> = very light powders. <del>DUST?
 0-49</del><ins>DUST?{br} 0-49</ins> = <del>liquids.
50-99</del><ins>liquids.{br}50-99</ins> = default <del>powders.
  100</del><ins>powders.{br}  100</ins> = <del>solids.
   -1</del><ins>solids.{br}   -1</ins> = energy particles (PHOT/NEUT/ELEC/PROT).<ins>

Note that nothing prevents you making a 101-weight gas, for example.</ins>

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

[Here's a list of all Properties flags and their descriptions.|Properties]

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}


!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS \
                         Simulation* sim, int index, int x, int y, \
                         int surround_space, int no_type, Particle *parts, \
                         int pmap[YRES][XRES]}}
where sim is a [Simulation] reference, 
index is the particle index in the parts array,
x, y are the particle's coordinates, 
surround_space is basically 8 minus the amount of particles of the same type around this one, 
no_type is the amount of empty space around this particle, 
parts is the reference to the [particle] array with all particles in it, and 
pmap is a two-dimensional array of integers that are created by shifting the particle index left 8 bits and using the last 8 bits to store the particle type right next to it. The particle index can be retrieved by using {{pmap[y][x]&gt;&gt;8}} and the particle type can be retrieved by using {{pmap[y][x] &amp; 0xFF}}.

In Lua, the function is passed these values:
{{int index, int x, int y, int surround_space, int nt}}
Any further interaction with the simulation can be done in the [simulation|sim] object.

Once you define your function, the assignment to this property is very simple: 

{{Update = &amp;amp;Element_BCOL::update;}}

Or in Lua, 

{{elem.property(elementID, &quot;Update&quot;, myUpdate)}}
{{tpt.update_func(myUpdate, elementID)}}


!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

Pixel modes are listed [here|Pixel modes]. 

cola/r/g/b are colour values from 0 to 255, and firea/r/g/b are the same except for the fiery glow. 

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS \
     Renderer * ren, Particle *cpart, int nx, int ny, \
     int *pixel_mode, int *cola, int *colr, int *colg, \
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}

In C++, you also get access to the Renderer object, current Particle object (you can do graphics based on particle properties!), and you also get the particle's position in nx and ny.

! Transitions


Transitions are really easy. Imagine you've got a line that you carefully split
into three sections: a middle where your element lives happily, and a lower edge
and a higher edge too, after which your element decides it doesn't stand the
heat or pressure anymore and transforms into another element.

{html}&amp;lt;img src=&quot;static/transition-line.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;400px&quot;&gt;{/html}

Before we go on with the line theory, there's a few types of special definitions
in the C++ version you can use instead if you never want to transition to
another element at one point.

{{IPL = Impossibly Low Pressure (which TPT will never reach!)
IPH = Impossibly High Pressure
ITL = Impossibly Low Temperature
ITH = Impossibly High Temperature
NT  = No Type}}

Then there's the properties you need to change. There's two aforementioned &quot;lines&quot;
and a total of 2 x 2 x 2 = 8 properties we need to change. 

!! LowPressure

LowPressure keeps track of a lower limit of pressure: if the pressure around
this particle drops below LowPressure, turn this particle into
LowPressureTransition.

{{LowPressure = IPL;
LowPressureTransition = NT;}}

!! HighPressure

HighPressure keeps track of an upper limit of pressure: if the pressure around
this particle drops below HighPressure, turn this particle into
HighPressureTransition.

{{HighPressure = IPH; 
HighPressureTransition = NT;}}

!! LowTemperature

LowTemperature keeps track of a lower limit of temperature: if the temperature
around this particle drops below LowTemperature, turn this particle into
LowTemperatureTransition.

{{LowTemperature = ITL;
LowTemperatureTransition = NT;}}

!! HighTemperature

HighTemperature keeps track of an upper limit of temperature: if the temperature
around this particle drops below HighTemperature, turn this particle into
HighTemperatureTransition.

{{HighTemperature = ITH;
HighTemperatureTransition = NT;}}

!! Examples

Turn your element into DUST at -15 pressure:
{{LowPressure = -15.0f; 
LowPressureTransition = PT_DUST;}}

Turn your element into FIRE at 500&amp;deg;C: 
{{HighTemperature = 500.0f + 273.15f;
HighTemperatureTransition = PT_FIRE;}}

Don't do anything on a low temperature:
{{LowTemperature = ITL; 
LowTemperatureTransition = NT;}}


{tags:Elements, Properties, Transitions}
</pre></description>
	</item>

	<item>
	  <title>Pixel modes</title>
	  <pubDate>Thu, 03 Jul 2014 13:03:05 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Pixel+modes</link>
	  <description><pre id="diff"><ins>Pixel modes are like Properties, except for graphics! Basically it's an integer with as many different bit-flags inside as possible.

There's {html}&amp;lt;a href=&quot;static/Particle_Drawing_Modes.png&quot;&gt;an image&amp;lt;/a&gt;{/html} of different modes, courtesy of [jacksonmj|http://tpt.io/@jacksonmj], which is under the CC BY-NC-SA license.
</ins>
(Up to date as of commit [ebe145b39ff1bc28912ed9e4ac058aeab0214388|https://github.com/simtr/The-Powder-Toy/blob/ebe145b39ff1bc28912ed9e4ac058aeab0214388/src/simulation/ElementGraphics.h#L4-L29])

{{#define PMODE		0x00000FFF // extract PMODEs from pixel_mode
#define PMODE_NONE	0x00000000
#define PMODE_FLAT	0x00000001
#define PMODE_BLOB	0x00000002
#define PMODE_BLUR	0x00000004
#define PMODE_GLOW	0x00000008
#define PMODE_SPARK	0x00000010
#define PMODE_FLARE	0x00000020
#define PMODE_LFLARE	0x00000040
#define PMODE_ADD	0x00000080
#define PMODE_BLEND	0x00000100
#define PSPEC_STICKMAN	0x00000200

#define OPTIONS		0x0000F000 // extract OPTIONs from pixel_mode
#define NO_DECO		0x00001000
#define DECO_FIRE	0x00002000

#define FIREMODE	0x00FF0000 // extract fire modes from pixel_mode
#define FIRE_ADD	0x00010000
#define FIRE_BLEND	0x00020000

#define EFFECT		0xFF000000 // extract effect modes from pixel_mode
#define EFFECT_GRAVIN	0x01000000
#define EFFECT_GRAVOUT	0x02000000
#define EFFECT_LINES	0x04000000
#define EFFECT_DBGLINES	0x08000000}}

! PMODE_NONE
Prevents anything from being drawn, like WARP.

! PMODE_FLAT
Draw an opaque pixel, aka transparency is not applied.

! PMODE_BLOB
Adds a blobby effect, like you were using blob (5) display mode

! PMODE_BLUR
Liquids in Fancy display apply this. Adds a blur and makes the pixels remain sharp as well.

! PMODE_GLOW
Plain ol' glow. Stuff like ARAY (In fancy display) use this.

! PMODE_SPARK
Kinda dim PMODE_FLARE - GBMB uses this - beams running horizontally and vertically + glow to emphasize brightness

! PMODE_FLARE
Regularly bright PMODE_FLARE - BOMB uses this - beams running horizontally and vertically

! PMODE_LFLARE
Large and super bright PMODE_FLARE - DEST is the only thing using this.

! PMODE_ADD
This adds some magic to the equation to make multiple layered particles add up to be brighter than one particle alone.

! PMODE_BLEND
Even more magical than PMODE_ADD, somehow better for OpenGL? 

! PSPEC_STICKMAN
Something very STKM specific that won't work anywhere except on STKM

! NO_DECO
Disables decorations on this element (LCRY does this as well as some magic to paint itself colours)

! DECO_FIRE
The fire/blurriness colors get decorations too. Gasses might use this.

! FIRE_ADD
Adds fire colors around the element (although weak ones - LAVA and LIGH lines use that)

! FIRE_BLEND
Adds more impressive fire colors around the element. Gasses use this for their coloring.

! EFFECT_GRAVIN, EFFECT_GRAVOUT
PRTI/PRTO effect flags: note that they also need magic life/ctype variables, which I may or may not know how to set.
</pre></description>
	</item>

	<item>
	  <title>Pixel modes</title>
	  <pubDate>Thu, 03 Jul 2014 12:58:39 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Pixel+modes</link>
	  <description><pre id="diff"><ins>(Up to date as of commit [ebe145b39ff1bc28912ed9e4ac058aeab0214388|https://github.com/simtr/The-Powder-Toy/blob/ebe145b39ff1bc28912ed9e4ac058aeab0214388/src/simulation/ElementGraphics.h#L4-L29])

{{#define PMODE		0x00000FFF // extract PMODEs from pixel_mode
#define PMODE_NONE	0x00000000
#define PMODE_FLAT	0x00000001
#define PMODE_BLOB	0x00000002
#define PMODE_BLUR	0x00000004
#define PMODE_GLOW	0x00000008
#define PMODE_SPARK	0x00000010
#define PMODE_FLARE	0x00000020
#define PMODE_LFLARE	0x00000040
#define PMODE_ADD	0x00000080
#define PMODE_BLEND	0x00000100
#define PSPEC_STICKMAN	0x00000200

#define OPTIONS		0x0000F000 // extract OPTIONs from pixel_mode
#define NO_DECO		0x00001000
#define DECO_FIRE	0x00002000

#define FIREMODE	0x00FF0000 // extract fire modes from pixel_mode
#define FIRE_ADD	0x00010000
#define FIRE_BLEND	0x00020000

#define EFFECT		0xFF000000 // extract effect modes from pixel_mode
#define EFFECT_GRAVIN	0x01000000
#define EFFECT_GRAVOUT	0x02000000
#define EFFECT_LINES	0x04000000
#define EFFECT_DBGLINES	0x08000000}}

! PMODE_NONE
Prevents anything from being drawn, like WARP.

! PMODE_FLAT
Draw an opaque pixel, aka transparency is not applied.

! PMODE_BLOB
Adds a blobby effect, like you were using blob (5) display mode

! PMODE_BLUR
Liquids in Fancy display apply this. Adds a blur and makes the pixels remain sharp as well.

! PMODE_GLOW
Plain ol' glow. Stuff like ARAY (In fancy display) use this.

! PMODE_SPARK
Kinda dim PMODE_FLARE - GBMB uses this - beams running horizontally and vertically + glow to emphasize brightness

! PMODE_FLARE
Regularly bright PMODE_FLARE - BOMB uses this - beams running horizontally and vertically

! PMODE_LFLARE
Large and super bright PMODE_FLARE - DEST is the only thing using this.

! PMODE_ADD
This adds some magic to the equation to make multiple layered particles add up to be brighter than one particle alone.

! PMODE_BLEND
Even more magical than PMODE_ADD, somehow better for OpenGL? 

! PSPEC_STICKMAN
Something very STKM specific that won't work anywhere except on STKM

! NO_DECO
Disables decorations on this element (LCRY does this as well as some magic to paint itself colours)

! DECO_FIRE
The fire/blurriness colors get decorations too. Gasses might use this.

! FIRE_ADD
Adds fire colors around the element (although weak ones - LAVA and LIGH lines use that)

! FIRE_BLEND
Adds more impressive fire colors around the element. Gasses use this for their coloring.

! EFFECT_GRAVIN, EFFECT_GRAVOUT
PRTI/PRTO effect flags: note that they also need magic life/ctype variables, which I may or may not know how to set.</ins>
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:51:47 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior. {br} 1 = Explodes with fire. {br} 2 = Explodes with &gt;2.5 pressure as well as fire.


!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

[Here's a list of all Properties flags and their descriptions.|Properties]

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}


!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS \
                         Simulation* sim, int index, int x, int y, \
                         int surround_space, int no_type, Particle *parts, \
                         int pmap[YRES][XRES]}}
where sim is a [Simulation] reference, 
index is the particle index in the parts array,
x, y are the particle's coordinates, 
surround_space is basically 8 minus the amount of particles of the same type around this one, 
no_type is the amount of empty space around this particle, 
parts is the reference to the [particle] array with all particles in it, and 
pmap is a two-dimensional array of integers that are created by shifting the particle index left 8 bits and using the last 8 bits to store the particle type right next to it. The particle index can be retrieved by using {{pmap[y][x]&gt;&gt;8}} and the particle type can be retrieved by using {{pmap[y][x] &amp; 0xFF}}.

In Lua, the function is passed these values:
{{int index, int x, int y, int surround_space, int nt}}
Any further interaction with the simulation can be done in the [simulation|sim] object.

Once you define your function, the assignment to this property is very simple: 

{{Update = &amp;amp;Element_BCOL::update;}}

Or in Lua, 

{{elem.property(elementID, &quot;Update&quot;, myUpdate)}}
{{tpt.update_func(myUpdate, elementID)}}


!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.
<ins>
Pixel modes are listed [here|Pixel modes]. 

cola/r/g/b are colour values from 0 to 255, and firea/r/g/b are the same except for the fiery glow. </ins>

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS <del>Renderer</del><ins>\
     Renderer</ins> * ren, Particle *cpart, int nx, int ny, <del>
     int</del><ins>\
     int</ins> *pixel_mode, int *cola, int *colr, int *colg, <del></del><ins>\</ins>
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}
<ins>
In C++, you also get access to the Renderer object, current Particle object (you can do graphics based on particle properties!), and you also get the particle's position in nx and ny.</ins>

! Transitions


Transitions are really easy. Imagine you've got a line that you carefully split
into three sections: a middle where your element lives happily, and a lower edge
and a higher edge too, after which your element decides it doesn't stand the
heat or pressure anymore and transforms into another element.

{html}&amp;lt;img src=&quot;static/transition-line.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;400px&quot;&gt;{/html}

Before we go on with the line theory, there's a few types of special definitions
in the C++ version you can use instead if you never want to transition to
another element at one point.

{{IPL = Impossibly Low Pressure (which TPT will never reach!)
IPH = Impossibly High Pressure
ITL = Impossibly Low Temperature
ITH = Impossibly High Temperature
NT  = No Type}}

Then there's the properties you need to change. There's two aforementioned &quot;lines&quot;
and a total of 2 x 2 x 2 = 8 properties we need to change. 

!! LowPressure

LowPressure keeps track of a lower limit of pressure: if the pressure around
this particle drops below LowPressure, turn this particle into
LowPressureTransition.

{{LowPressure = IPL;
LowPressureTransition = NT;}}

!! HighPressure

HighPressure keeps track of an upper limit of pressure: if the pressure around
this particle drops below HighPressure, turn this particle into
HighPressureTransition.

{{HighPressure = IPH; 
HighPressureTransition = NT;}}

!! LowTemperature

LowTemperature keeps track of a lower limit of temperature: if the temperature
around this particle drops below LowTemperature, turn this particle into
LowTemperatureTransition.

{{LowTemperature = ITL;
LowTemperatureTransition = NT;}}

!! HighTemperature

HighTemperature keeps track of an upper limit of temperature: if the temperature
around this particle drops below HighTemperature, turn this particle into
HighTemperatureTransition.

{{HighTemperature = ITH;
HighTemperatureTransition = NT;}}

!! Examples

Turn your element into DUST at -15 pressure:
{{LowPressure = -15.0f; 
LowPressureTransition = PT_DUST;}}

Turn your element into FIRE at 500&amp;deg;C: 
{{HighTemperature = 500.0f + 273.15f;
HighTemperatureTransition = PT_FIRE;}}

Don't do anything on a low temperature:
{{LowTemperature = ITL; 
LowTemperatureTransition = NT;}}


{tags:Elements, Properties, Transitions}
</pre></description>
	</item>

	<item>
	  <title>particle</title>
	  <pubDate>Thu, 03 Jul 2014 12:47:11 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=particle</link>
	  <description><pre id="diff"><ins>{redirect:Particle properties}</ins>
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:44:51 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.<del>
1</del><ins> {br} 1</ins> = Explodes with fire.<del>
2</del><ins> {br} 2</ins> = Explodes with &gt;2.5 pressure as well as fire.<ins>
</ins>

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

[Here's a list of all Properties flags and their descriptions.|Properties]

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}


!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS \
                         Simulation* sim, int index, int x, int y, \
                         int surround_space, int no_type, Particle *parts, \
                         int pmap[YRES][XRES]}}
where sim is a [Simulation] reference, 
index is the particle index in the parts array,
x, y are the particle's coordinates, 
surround_space is basically 8 minus the amount of particles of the same type around this one, 
no_type is the amount of empty space around this particle, 
parts is the reference to the [particle] array with all particles in it, and 
pmap is a two-dimensional array of integers that are created by shifting the particle index left 8 bits and using the last 8 bits to store the particle type right next to it. The particle index can be retrieved by using {{pmap[y][x]&gt;&gt;8}} and the particle type can be retrieved by using {{pmap[y][x] &amp; 0xFF}}.

In Lua, the function is passed these values:
{{int index, int x, int y, int surround_space, int nt}}
Any further interaction with the simulation can be done in the [simulation|sim] object.

Once you define your function, the assignment to this property is very simple: 

{{Update = &amp;amp;Element_BCOL::update;}}

Or in Lua, 

{{elem.property(elementID, &quot;Update&quot;, myUpdate)}}
{{tpt.update_func(myUpdate, elementID)}}


!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}

! Transitions


Transitions are really easy. Imagine you've got a line that you carefully split
into three sections: a middle where your element lives happily, and a lower edge
and a higher edge too, after which your element decides it doesn't stand the
heat or pressure anymore and transforms into another element.

{html}&amp;lt;img src=&quot;static/transition-line.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;400px&quot;&gt;{/html}

Before we go on with the line theory, there's a few types of special definitions
in the C++ version you can use instead if you never want to transition to
another element at one point.

{{IPL = Impossibly Low Pressure (which TPT will never reach!)
IPH = Impossibly High Pressure
ITL = Impossibly Low Temperature
ITH = Impossibly High Temperature
NT  = No Type}}

Then there's the properties you need to change. There's two aforementioned &quot;lines&quot;
and a total of 2 x 2 x 2 = 8 properties we need to change. 

!! LowPressure

LowPressure keeps track of a lower limit of pressure: if the pressure around
this particle drops below LowPressure, turn this particle into
LowPressureTransition.

{{LowPressure = IPL;
LowPressureTransition = NT;}}

!! HighPressure

HighPressure keeps track of an upper limit of pressure: if the pressure around
this particle drops below HighPressure, turn this particle into
HighPressureTransition.

{{HighPressure = IPH; 
HighPressureTransition = NT;}}

!! LowTemperature

LowTemperature keeps track of a lower limit of temperature: if the temperature
around this particle drops below LowTemperature, turn this particle into
LowTemperatureTransition.

{{LowTemperature = ITL;
LowTemperatureTransition = NT;}}

!! HighTemperature

HighTemperature keeps track of an upper limit of temperature: if the temperature
around this particle drops below HighTemperature, turn this particle into
HighTemperatureTransition.

{{HighTemperature = ITH;
HighTemperatureTransition = NT;}}

!! Examples

Turn your element into DUST at -15 pressure:
{{LowPressure = -15.0f; 
LowPressureTransition = PT_DUST;}}

Turn your element into FIRE at 500&amp;deg;C: 
{{HighTemperature = 500.0f + 273.15f;
HighTemperatureTransition = PT_FIRE;}}

Don't do anything on a low temperature:
{{LowTemperature = ITL; 
LowTemperatureTransition = NT;}}


{tags:Elements, Properties, Transitions}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:44:10 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

[Here's a list of all Properties flags and their descriptions.|Properties]

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}


!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS \
                         Simulation* sim, int index, int x, int y, \
                         int surround_space, int no_type, Particle *parts, \
                         int pmap[YRES][XRES]}}
where sim is a [Simulation] reference, 
index is the particle index in the parts array,
x, y are the particle's coordinates, 
surround_space is basically 8 minus the amount of particles of the same type around this one, 
no_type is the amount of empty space around this particle, 
parts is the reference to the [particle] array with all particles in it, and 
pmap is a two-dimensional array of integers that are created by shifting the particle index left 8 bits and using the last 8 bits to store the particle type right next to it. The particle index can be retrieved by using {{pmap[y][x]&gt;&gt;8}} and the particle type can be retrieved by using {{pmap[y][x] &amp; 0xFF}}.

<del>(in Lua): number</del><ins>In Lua, the function is passed these values:
{{int</ins> index, <del>number</del><ins>int</ins> x, <del>number</del><ins>int</ins> y, <del>number</del><ins>int</ins> surround_space, <del>number nt</del><ins>int nt}}
Any further interaction with the simulation can be done in the [simulation|sim] object.</ins>

Once you define your function, the assignment to this property is very simple: 

{{Update = &amp;amp;Element_BCOL::update;}}

Or in Lua, 

{{elem.property(elementID, &quot;Update&quot;, myUpdate)}}
{{tpt.update_func(myUpdate, elementID)}}


!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}

! Transitions


Transitions are really easy. Imagine you've got a line that you carefully split
into three sections: a middle where your element lives happily, and a lower edge
and a higher edge too, after which your element decides it doesn't stand the
heat or pressure anymore and transforms into another element.

{html}&amp;lt;img src=&quot;static/transition-line.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;400px&quot;&gt;{/html}

Before we go on with the line theory, there's a few types of special definitions
in the C++ version you can use instead if you never want to transition to
another element at one point.

{{IPL = Impossibly Low Pressure (which TPT will never reach!)
IPH = Impossibly High Pressure
ITL = Impossibly Low Temperature
ITH = Impossibly High Temperature
NT  = No Type}}

Then there's the properties you need to change. There's two aforementioned &quot;lines&quot;
and a total of 2 x 2 x 2 = 8 properties we need to change. 

!! LowPressure

LowPressure keeps track of a lower limit of pressure: if the pressure around
this particle drops below LowPressure, turn this particle into
LowPressureTransition.

{{LowPressure = IPL;
LowPressureTransition = NT;}}

!! HighPressure

HighPressure keeps track of an upper limit of pressure: if the pressure around
this particle drops below HighPressure, turn this particle into
HighPressureTransition.

{{HighPressure = IPH; 
HighPressureTransition = NT;}}

!! LowTemperature

LowTemperature keeps track of a lower limit of temperature: if the temperature
around this particle drops below LowTemperature, turn this particle into
LowTemperatureTransition.

{{LowTemperature = ITL;
LowTemperatureTransition = NT;}}

!! HighTemperature

HighTemperature keeps track of an upper limit of temperature: if the temperature
around this particle drops below HighTemperature, turn this particle into
HighTemperatureTransition.

{{HighTemperature = ITH;
HighTemperatureTransition = NT;}}

!! Examples

Turn your element into DUST at -15 pressure:
{{LowPressure = -15.0f; 
LowPressureTransition = PT_DUST;}}

Turn your element into FIRE at 500&amp;deg;C: 
{{HighTemperature = 500.0f + 273.15f;
HighTemperatureTransition = PT_FIRE;}}

Don't do anything on a low temperature:
{{LowTemperature = ITL; 
LowTemperatureTransition = NT;}}


{tags:Elements, Properties, Transitions}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:42:45 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

[Here's a list of all Properties flags and their descriptions.|Properties]

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}


!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS <del>Simulation*</del><ins>\
                         Simulation*</ins> sim, int index, int x, int y, <del>
                         int</del><ins>\
                         int</ins> surround_space, int no_type, Particle *parts, <del></del><ins>\</ins>
                         int pmap[YRES][XRES]}}
<ins>where sim is a [Simulation] reference, 
index is the particle index in the parts array,
x, y are the particle's coordinates, 
surround_space is basically 8 minus the amount of particles of the same type around this one, 
no_type is the amount of empty space around this particle, 
parts is the reference to the [particle] array with all particles in it, and 
pmap is a two-dimensional array of integers that are created by shifting the particle index left 8 bits and using the last 8 bits to store the particle type right next to it. The particle index can be retrieved by using {{pmap[y][x]&gt;&gt;8}} and the particle type can be retrieved by using {{pmap[y][x] &amp; 0xFF}}.</ins>

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

<del>Update</del><ins>{{Update</ins> = <del>&amp;amp;Element_BCOL::update;</del><ins>&amp;amp;Element_BCOL::update;}}

Or in Lua, 

{{elem.property(elementID, &quot;Update&quot;, myUpdate)}}
{{tpt.update_func(myUpdate, elementID)}}
</ins>

!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}

! Transitions


Transitions are really easy. Imagine you've got a line that you carefully split
into three sections: a middle where your element lives happily, and a lower edge
and a higher edge too, after which your element decides it doesn't stand the
heat or pressure anymore and transforms into another element.

{html}&amp;lt;img src=&quot;static/transition-line.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;400px&quot;&gt;{/html}

Before we go on with the line theory, there's a few types of special definitions
in the C++ version you can use instead if you never want to transition to
another element at one point.

{{IPL = Impossibly Low Pressure (which TPT will never reach!)
IPH = Impossibly High Pressure
ITL = Impossibly Low Temperature
ITH = Impossibly High Temperature
NT  = No Type}}

Then there's the properties you need to change. There's two aforementioned &quot;lines&quot;
and a total of 2 x 2 x 2 = 8 properties we need to change. 

!! LowPressure

LowPressure keeps track of a lower limit of pressure: if the pressure around
this particle drops below LowPressure, turn this particle into
LowPressureTransition.

{{LowPressure = IPL;
LowPressureTransition = NT;}}

!! HighPressure

HighPressure keeps track of an upper limit of pressure: if the pressure around
this particle drops below HighPressure, turn this particle into
HighPressureTransition.

{{HighPressure = IPH; 
HighPressureTransition = NT;}}

!! LowTemperature

LowTemperature keeps track of a lower limit of temperature: if the temperature
around this particle drops below LowTemperature, turn this particle into
LowTemperatureTransition.

{{LowTemperature = ITL;
LowTemperatureTransition = NT;}}

!! HighTemperature

HighTemperature keeps track of an upper limit of temperature: if the temperature
around this particle drops below HighTemperature, turn this particle into
HighTemperatureTransition.

{{HighTemperature = ITH;
HighTemperatureTransition = NT;}}

!! Examples

Turn your element into DUST at -15 pressure:
{{LowPressure = -15.0f; 
LowPressureTransition = PT_DUST;}}

Turn your element into FIRE at 500&amp;deg;C: 
{{HighTemperature = 500.0f + 273.15f;
HighTemperatureTransition = PT_FIRE;}}

Don't do anything on a low temperature:
{{LowTemperature = ITL; 
LowTemperatureTransition = NT;}}


{tags:Elements, Properties, Transitions}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:33:40 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff"></pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:24:30 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

[Here's a list of all Properties flags and their descriptions.|Properties]

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}


!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS Simulation* sim, int index, int x, int y, 
                         int surround_space, int no_type, Particle *parts, 
                         int pmap[YRES][XRES]}}

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

Update = &amp;amp;Element_BCOL::update;

!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}

! Transitions


Transitions are really easy. Imagine you've got a line that you carefully split
into three sections: a middle where your element lives happily, and a lower edge
and a higher edge too, after which your element decides it doesn't stand the
heat or pressure anymore and transforms into another element.

{html}&amp;lt;img <del>src=&quot;static/transition-line.svg&quot;&gt;{/html}</del><ins>src=&quot;static/transition-line.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;400px&quot;&gt;{/html}</ins>

Before we go on with the line theory, there's a few types of special definitions
in the C++ version you can use instead if you never want to transition to
another element at one point.

{{IPL = Impossibly Low Pressure (which TPT will never reach!)
IPH = Impossibly High Pressure
ITL = Impossibly Low Temperature
ITH = Impossibly High Temperature
NT  = No Type}}

Then there's the properties you need to change. There's two aforementioned &quot;lines&quot;
and a total of 2 x 2 x 2 = 8 properties we need to change. 

!! LowPressure

LowPressure keeps track of a lower limit of pressure: if the pressure around
this particle drops below LowPressure, turn this particle into
LowPressureTransition.

{{LowPressure = IPL;
LowPressureTransition = NT;}}

!! HighPressure

HighPressure keeps track of an upper limit of pressure: if the pressure around
this particle drops below HighPressure, turn this particle into
HighPressureTransition.

{{HighPressure = IPH; 
HighPressureTransition = NT;}}

!! LowTemperature

LowTemperature keeps track of a lower limit of temperature: if the temperature
around this particle drops below LowTemperature, turn this particle into
LowTemperatureTransition.

{{LowTemperature = ITL;
LowTemperatureTransition = NT;}}

!! HighTemperature

HighTemperature keeps track of an upper limit of temperature: if the temperature
around this particle drops below HighTemperature, turn this particle into
HighTemperatureTransition.

{{HighTemperature = ITH;
HighTemperatureTransition = NT;}}

!! Examples

Turn your element into DUST at -15 pressure:
{{LowPressure = -15.0f; 
LowPressureTransition = PT_DUST;}}

Turn your element into FIRE at 500&amp;deg;C: 
{{HighTemperature = 500.0f + 273.15f;
HighTemperatureTransition = PT_FIRE;}}

Don't do anything on a low temperature:
{{LowTemperature = ITL; 
LowTemperatureTransition = NT;}}


{tags:Elements, Properties, Transitions}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:23:49 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff"></pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:21:52 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

[Here's a list of all Properties flags and their descriptions.|Properties]

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}


!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS Simulation* sim, int index, int x, int y, 
                         int surround_space, int no_type, Particle *parts, 
                         int pmap[YRES][XRES]}}

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

Update = &amp;amp;Element_BCOL::update;

!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}

<del>{tags:Elements, Properties}</del><ins>! Transitions


Transitions are really easy. Imagine you've got a line that you carefully split
into three sections: a middle where your element lives happily, and a lower edge
and a higher edge too, after which your element decides it doesn't stand the
heat or pressure anymore and transforms into another element.

{html}&amp;lt;img src=&quot;static/transition-line.svg&quot;&gt;{/html}

Before we go on with the line theory, there's a few types of special definitions
in the C++ version you can use instead if you never want to transition to
another element at one point.

{{IPL = Impossibly Low Pressure (which TPT will never reach!)
IPH = Impossibly High Pressure
ITL = Impossibly Low Temperature
ITH = Impossibly High Temperature
NT  = No Type}}

Then there's the properties you need to change. There's two aforementioned &quot;lines&quot;
and a total of 2 x 2 x 2 = 8 properties we need to change. 

!! LowPressure

LowPressure keeps track of a lower limit of pressure: if the pressure around
this particle drops below LowPressure, turn this particle into
LowPressureTransition.

{{LowPressure = IPL;
LowPressureTransition = NT;}}

!! HighPressure

HighPressure keeps track of an upper limit of pressure: if the pressure around
this particle drops below HighPressure, turn this particle into
HighPressureTransition.

{{HighPressure = IPH; 
HighPressureTransition = NT;}}

!! LowTemperature

LowTemperature keeps track of a lower limit of temperature: if the temperature
around this particle drops below LowTemperature, turn this particle into
LowTemperatureTransition.

{{LowTemperature = ITL;
LowTemperatureTransition = NT;}}

!! HighTemperature

HighTemperature keeps track of an upper limit of temperature: if the temperature
around this particle drops below HighTemperature, turn this particle into
HighTemperatureTransition.

{{HighTemperature = ITH;
HighTemperatureTransition = NT;}}

!! Examples

Turn your element into DUST at -15 pressure:
{{LowPressure = -15.0f; 
LowPressureTransition = PT_DUST;}}

Turn your element into FIRE at 500&amp;deg;C: 
{{HighTemperature = 500.0f + 273.15f;
HighTemperatureTransition = PT_FIRE;}}

Don't do anything on a low temperature:
{{LowTemperature = ITL; 
LowTemperatureTransition = NT;}}


{tags:Elements, Properties, Transitions}</ins>
</pre></description>
	</item>

	<item>
	  <title>Particle properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:08:40 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Particle+properties</link>
	  <description><pre id="diff"></pre></description>
	</item>

	<item>
	  <title>Particle properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:06:41 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Particle+properties</link>
	  <description><pre id="diff">{{struct Particle
{
	int type;
	int life, ctype;
	float x, y, vx, vy;
	float temp;
	float pavg[2];
	int flags;
	int tmp;
	int tmp2;
	unsigned int dcolour;
	static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

! type

What [element ID|Element IDs] is this? 
You can use the console and set it to the element name as well, but the console will silently convert your element name into an element ID.

! life

(How many frames does your particle have left to exist?)
A lot of elements use it as the above, but it's actually just anything you want it to be. Just another integer.
It's really easy, however, to make this integer count down to 0 from its current value. Just add [PROP_LIFE_DEC|Properties#_PROP_LIFE_DEC]. Also it's really easy to delete the particle automatically when its life value hits 0 - see [PROP_LIFE_KILL|Properties#_PROP_LIFE_KILL]

! ctype

If your particle needs to store another [element ID|Element IDs], this is the place to put it. Otherwise, it's just another integer. For example, CLNE stores what element it clones here. CRAY too.
The game user interface usually displays an element's ctype value with the element name the ID is supposed to stand for. For example, when you hover over a DUST with ctype 28, you can see DUST (DMND).

! x, y

This is the particle's position on screen. Multiple particles can overlap one position, but this will break things that rely on pmap to find particles around them (every element!). 

! vx, vy

This stores the number, that is added to the x and y positions every frame. 

A positive vx means the particle is moving towards the right edge, while a positive vy means the particle is moving towards the bottom edge. 

! temp

This stores the particle's temperature in Kelvins. Valid temperatures are clamped between 0 and 10000 K and are displayed in Celsius, which is simply offset by -273.15 degrees. No scientific accuracy guaranteed&amp;trade;

! pavg

(To be written)

! tmp, tmp2

Those are two generic integers, that you can use for whatever purpose imaginable. It's common nowadays to set different operation modes based on the TMP value.

! dcolour

This stores the element's decoration colour which is drawn on top of the element's actual colour and can be changed by the user. It uses a simple 32-bit colour format, where the <del>colour bits look</del><ins>entire value looks something</ins> like <del>this:

{html}0x&amp;lt;span style=&quot;color: red;&quot;&gt;RR&amp;lt;/span&gt;&amp;lt;span style=&quot;color: green;&quot;&gt;GG&amp;lt;/span&gt;&amp;lt;span style=&quot;color: blue;&quot;&gt;BB&amp;lt;/span&gt;AA{/html}</del><ins>0xAARRGGBB, where AA represents the element's transparency, RR represents the red component, GG the green component and BB the blue component. All values range from 0x00 to 0xFF (or 0 to 255). </ins>
</pre></description>
	</item>

	<item>
	  <title>Particle properties</title>
	  <pubDate>Thu, 03 Jul 2014 12:05:35 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Particle+properties</link>
	  <description><pre id="diff">{{struct Particle
{
	int type;
	int life, ctype;
	float x, y, vx, vy;
	float temp;
	float pavg[2];
	int flags;
	int tmp;
	int tmp2;
	unsigned int dcolour;
	static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

<ins>! type

What [element ID|Element IDs] is this? 
You can use the console and set it to the element name as well, but the console will silently convert your element name into an element ID.

! life

(How many frames does your particle have left to exist?)
A lot of elements use it as the above, but it's actually just anything you want it to be. Just another integer.
It's really easy, however, to make this integer count down to 0 from its current value. Just add [PROP_LIFE_DEC|Properties#_PROP_LIFE_DEC]. Also it's really easy to delete the particle automatically when its life value hits 0 - see [PROP_LIFE_KILL|Properties#_PROP_LIFE_KILL]

! ctype

If your particle needs to store another [element ID|Element IDs], this is the place to put it. Otherwise, it's just another integer. For example, CLNE stores what element it clones here. CRAY too.
The game user interface usually displays an element's ctype value with the element name the ID is supposed to stand for. For example, when you hover over a DUST with ctype 28, you can see DUST (DMND).

! x, y

This is the particle's position on screen. Multiple particles can overlap one position, but this will break things that rely on pmap to find particles around them (every element!). 

! vx, vy

This stores the number, that is added to the x and y positions every frame. 

A positive vx means the particle is moving towards the right edge, while a positive vy means the particle is moving towards the bottom edge. 

! temp

This stores the particle's temperature in Kelvins. Valid temperatures are clamped between 0 and 10000 K and are displayed in Celsius, which is simply offset by -273.15 degrees. No scientific accuracy guaranteed&amp;trade;

! pavg

(To be written)

! tmp, tmp2

Those are two generic integers, that you can use for whatever purpose imaginable. It's common nowadays to set different operation modes based on the TMP value.

! dcolour

This stores the element's decoration colour which is drawn on top of the element's actual colour and can be changed by the user. It uses a simple 32-bit colour format, where the colour bits look like this:

{html}0x&amp;lt;span style=&quot;color: red;&quot;&gt;RR&amp;lt;/span&gt;&amp;lt;span style=&quot;color: green;&quot;&gt;GG&amp;lt;/span&gt;&amp;lt;span style=&quot;color: blue;&quot;&gt;BB&amp;lt;/span&gt;AA{/html}</ins>
</pre></description>
	</item>

	<item>
	  <title>Properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:45:22 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Properties</link>
	  <description><pre id="diff">This is a list of all the different flags you can apply to the [element property|Element properties] called Properties.

(The list is valid of commit [b699bb176f41012a43c42dbbf1ec82b7e1c27d3d|https://github.com/simtr/The-Powder-Toy/blob/b699bb176f41012a43c42dbbf1ec82b7e1c27d3d/src/simulation/Elements.h#L13-L33])

If you think this isn't the right place to be, a few alternatives are listed below.

* [Element properties]
* [Particle properties]

! Lua

In Lua, you can access all the same properties under the [elem] table. 

{{elem.TYPE_PART}} 

! The list

{{#define TYPE_PART		0x00001  //1 Powders
#define TYPE_LIQUID		0x00002  //2 Liquids
#define TYPE_SOLID		0x00004  //4 Solids
#define TYPE_GAS		0x00008  //8 Gasses (Includes plasma)
#define TYPE_ENERGY		0x00010  //16 Energy (Thunder, Light, Neutrons etc.)
#define PROP_CONDUCTS		0x00020  //32 Conducts electricity
#define PROP_BLACK		0x00040  //64 Absorbs Photons (not currently implemented or used, a photwl attribute might be better)
#define PROP_NEUTPENETRATE	0x00080  //128 Penetrated by neutrons
#define PROP_NEUTABSORB		0x00100  //256 Absorbs neutrons, reflect is default
#define PROP_NEUTPASS		0x00200  //512 Neutrons pass through, such as with glass
#define PROP_DEADLY		0x00400  //1024 Is deadly for stickman
#define PROP_HOT_GLOW		0x00800  //2048 Hot Metal Glow
#define PROP_LIFE		0x01000  //4096 Is a GoL type
#define PROP_RADIOACTIVE	0x02000  //8192 Radioactive
#define PROP_LIFE_DEC		0x04000  //2**14 Life decreases by one every frame if &gt; zero
#define PROP_LIFE_KILL		0x08000  //2**15 Kill when life value is &amp;lt;= zero
#define PROP_LIFE_KILL_DEC	0x10000  //2**16 Kill when life value is decremented to &amp;lt;= zero
#define PROP_SPARKSETTLE	0x20000  //2**17 Allow Sparks/Embers to settle
#define PROP_NOAMBHEAT		0x40000  //2**18 Don't transfer or receive heat from ambient heat.
#define PROP_DRAWONCTYPE	0x80000  //2**19 Set its ctype to another element if the element is drawn upon it (like what CLNE does)
#define PROP_NOCTYPEDRAW	0x100000 // 2**20 When this element is drawn upon with, do not set ctype (like BCLN for CLNE)}}

<ins>! TYPE_PART</ins>

<ins>Value: 1
Powders

! TYPE_LIQUID

Value: 2
Liquids

! TYPE_SOLID

Value: 4
Solids

! TYPE_GAS

Value: 8
Gasses (plasma is actually a gas!)

! TYPE_ENERGY

Value: 16
Is an energy element (Thunder, Light, Neutrons etc.)
This ups the stacking limit and makes the particles not collide with each other.

! PROP_CONDUCTS

Value: 32
Conducts electricity.

! PROP_BLACK

Value: 64
Absorbs Photons (not currently implemented or used, a photwl attribute might be better)

! PROP_NEUTPENETRATE

Value: 128
Neutrons go through it. 

! PROP_NEUTABSORB

Value: 256
Absorbs neutrons instead of reflecting them back.

! PROP_NEUTPASS

Value: 512
Neutrons pass through, such as with glass

! PROP_DEADLY

Value: 1024
Kills stickman when the stickman touches the element.

! PROP_HOT_GLOW

Value: 2048
Adds that red hot metal glow to this element. 

! PROP_LIFE

Value: 4096
This element is actually a game-of-life element.

! PROP_RADIOACTIVE

Value: 8192
Radioactive (kills stickman on touch)

! PROP_LIFE_DEC

Value: 2^^14 
Decrease life by 1 every frame, until it reaches zero.

! PROP_LIFE_KILL

Value: 2^^15
Delete this particle when its life is zero or less. 

! PROP_LIFE_KILL_DEC

Value: 2^^16
A combination of PROP_LIFE_KILL and PROP_LIFE_DEC. 

! PROP_SPARKSETTLE

Value: 2^^17
Embers (EMBR) won't disappear on contact with this element.

! PROP_NOAMBHEAT

Value: 2^^18
Don't transfer or receive heat from ambient heat.

! PROP_DRAWONCTYPE

Value: 2^^19
Set its ctype to another element if the element is drawn upon it.
Basically works like CLNE - if you put down CLNE and try to draw something on it, this sets the clone's ctype internally to the something you wanted to draw on it. And that makes CLNE clone the element you chose.

! PROP_NOCTYPEDRAW

Value: 2^^20 
It blocks your element from being set as a ctype on elements that do use PROP_DRAWONCTYPE. For example, BCLN can't be normally set as a ctype on CLNE.</ins>

{tags:Elements, Properties}
</pre></description>
	</item>

	<item>
	  <title>Properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:35:27 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Properties</link>
	  <description><pre id="diff">This is a list of all the different flags you can apply to the [element property|Element properties] called Properties.

(The list is valid of commit [b699bb176f41012a43c42dbbf1ec82b7e1c27d3d|https://github.com/simtr/The-Powder-Toy/blob/b699bb176f41012a43c42dbbf1ec82b7e1c27d3d/src/simulation/Elements.h#L13-L33])

If you think this isn't the right place to be, a few alternatives are listed below.

* [Element properties]
* [Particle properties]

! Lua

In Lua, you can access all the same properties under the [elem] table. 

{{elem.TYPE_PART}} 

! The list

{{#define TYPE_PART		0x00001  //1 Powders
#define TYPE_LIQUID		0x00002  //2 Liquids
#define TYPE_SOLID		0x00004  //4 Solids
#define TYPE_GAS		0x00008  //8 Gasses (Includes plasma)
#define TYPE_ENERGY		0x00010  //16 Energy (Thunder, Light, Neutrons etc.)
#define PROP_CONDUCTS		0x00020  //32 Conducts electricity
#define PROP_BLACK		0x00040  //64 Absorbs Photons (not currently implemented or used, a photwl attribute might be better)
#define PROP_NEUTPENETRATE	0x00080  //128 Penetrated by neutrons
#define PROP_NEUTABSORB		0x00100  //256 Absorbs neutrons, reflect is default
#define PROP_NEUTPASS		0x00200  //512 Neutrons pass through, such as with glass
#define PROP_DEADLY		0x00400  //1024 Is deadly for stickman
#define PROP_HOT_GLOW		0x00800  //2048 Hot Metal Glow
#define PROP_LIFE		0x01000  //4096 Is a GoL type
#define PROP_RADIOACTIVE	0x02000  //8192 Radioactive
#define PROP_LIFE_DEC		0x04000  <del>//2^14</del><ins>//2**14</ins> Life decreases by one every frame if &gt; zero
#define PROP_LIFE_KILL		0x08000  <del>//2^15</del><ins>//2**15</ins> Kill when life value is &amp;lt;= zero
#define PROP_LIFE_KILL_DEC	0x10000  <del>//2^16</del><ins>//2**16</ins> Kill when life value is decremented to &amp;lt;= zero
#define PROP_SPARKSETTLE	0x20000  <del>//2^17</del><ins>//2**17</ins> Allow Sparks/Embers to settle
#define PROP_NOAMBHEAT		0x40000  <del>//2^18</del><ins>//2**18</ins> Don't transfer or receive heat from ambient heat.
#define PROP_DRAWONCTYPE	0x80000  <del>//2^19</del><ins>//2**19</ins> Set its ctype to another element if the element is drawn upon it (like what CLNE does)
#define PROP_NOCTYPEDRAW	0x100000 // <del>2^20</del><ins>2**20</ins> When this element is drawn upon with, do not set ctype (like BCLN for CLNE)}}



{tags:Elements, Properties}
</pre></description>
	</item>

	<item>
	  <title>Properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:34:39 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Properties</link>
	  <description><pre id="diff">This is a list of all the different flags you can apply to the [element property|Element properties] called Properties.

(The list is valid of commit [b699bb176f41012a43c42dbbf1ec82b7e1c27d3d|https://github.com/simtr/The-Powder-Toy/blob/b699bb176f41012a43c42dbbf1ec82b7e1c27d3d/src/simulation/Elements.h#L13-L33])

If you think this isn't the right place to be, a few alternatives are listed below.

* [Element properties]
* [Particle properties]

! Lua

In Lua, you can access all the same properties under the [elem] table. 

{{elem.TYPE_PART}} 

! The list

{{#define <del>TYPE_PART			0x00001</del><ins>TYPE_PART		0x00001</ins>  //1 Powders
#define <del>TYPE_LIQUID			0x00002</del><ins>TYPE_LIQUID		0x00002</ins>  //2 Liquids
#define <del>TYPE_SOLID			0x00004</del><ins>TYPE_SOLID		0x00004</ins>  //4 Solids
#define <del>TYPE_GAS			0x00008</del><ins>TYPE_GAS		0x00008</ins>  //8 Gasses (Includes plasma)
#define <del>TYPE_ENERGY			0x00010</del><ins>TYPE_ENERGY		0x00010</ins>  //16 Energy (Thunder, Light, Neutrons etc.)
#define PROP_CONDUCTS		0x00020  //32 Conducts electricity
#define <del>PROP_BLACK			0x00040</del><ins>PROP_BLACK		0x00040</ins>  //64 Absorbs Photons (not currently implemented or used, a photwl attribute might be better)
#define PROP_NEUTPENETRATE	0x00080  //128 Penetrated by neutrons
#define PROP_NEUTABSORB		0x00100  //256 Absorbs neutrons, reflect is default
#define PROP_NEUTPASS		0x00200  //512 Neutrons pass through, such as with glass
#define <del>PROP_DEADLY			0x00400</del><ins>PROP_DEADLY		0x00400</ins>  //1024 Is deadly for stickman
#define PROP_HOT_GLOW		0x00800  //2048 Hot Metal Glow
#define <del>PROP_LIFE			0x01000</del><ins>PROP_LIFE		0x01000</ins>  //4096 Is a GoL type
#define PROP_RADIOACTIVE	0x02000  //8192 Radioactive
#define PROP_LIFE_DEC		0x04000  //2^14 Life decreases by one every frame if &gt; zero
#define PROP_LIFE_KILL		0x08000  //2^15 Kill when life value is &amp;lt;= zero
#define PROP_LIFE_KILL_DEC	0x10000  //2^16 Kill when life value is decremented to &amp;lt;= zero
#define PROP_SPARKSETTLE	0x20000  //2^17 Allow Sparks/Embers to settle
#define PROP_NOAMBHEAT		0x40000  //2^18 Don't transfer or receive heat from ambient heat.
#define PROP_DRAWONCTYPE	0x80000  //2^19 Set its ctype to another element if the element is drawn upon it (like what CLNE does)
#define PROP_NOCTYPEDRAW	0x100000 // 2^20 When this element is drawn upon with, do not set ctype (like BCLN for CLNE)}}



{tags:Elements, Properties}
</pre></description>
	</item>

	<item>
	  <title>Properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:34:15 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Properties</link>
	  <description><pre id="diff"><ins>This is a list of all the different flags you can apply to the [element property|Element properties] called Properties.

(The list is valid of commit [b699bb176f41012a43c42dbbf1ec82b7e1c27d3d|https://github.com/simtr/The-Powder-Toy/blob/b699bb176f41012a43c42dbbf1ec82b7e1c27d3d/src/simulation/Elements.h#L13-L33])

If you think this isn't the right place to be, a few alternatives are listed below.

* [Element properties]
* [Particle properties]

! Lua

In Lua, you can access all the same properties under the [elem] table. 

{{elem.TYPE_PART}} 

! The list

{{#define TYPE_PART			0x00001  //1 Powders
#define TYPE_LIQUID			0x00002  //2 Liquids
#define TYPE_SOLID			0x00004  //4 Solids
#define TYPE_GAS			0x00008  //8 Gasses (Includes plasma)
#define TYPE_ENERGY			0x00010  //16 Energy (Thunder, Light, Neutrons etc.)
#define PROP_CONDUCTS		0x00020  //32 Conducts electricity
#define PROP_BLACK			0x00040  //64 Absorbs Photons (not currently implemented or used, a photwl attribute might be better)
#define PROP_NEUTPENETRATE	0x00080  //128 Penetrated by neutrons
#define PROP_NEUTABSORB		0x00100  //256 Absorbs neutrons, reflect is default
#define PROP_NEUTPASS		0x00200  //512 Neutrons pass through, such as with glass
#define PROP_DEADLY			0x00400  //1024 Is deadly for stickman
#define PROP_HOT_GLOW		0x00800  //2048 Hot Metal Glow
#define PROP_LIFE			0x01000  //4096 Is a GoL type
#define PROP_RADIOACTIVE	0x02000  //8192 Radioactive
#define PROP_LIFE_DEC		0x04000  //2^14 Life decreases by one every frame if &gt; zero
#define PROP_LIFE_KILL		0x08000  //2^15 Kill when life value is &amp;lt;= zero
#define PROP_LIFE_KILL_DEC	0x10000  //2^16 Kill when life value is decremented to &amp;lt;= zero
#define PROP_SPARKSETTLE	0x20000  //2^17 Allow Sparks/Embers to settle
#define PROP_NOAMBHEAT		0x40000  //2^18 Don't transfer or receive heat from ambient heat.
#define PROP_DRAWONCTYPE	0x80000  //2^19 Set its ctype to another element if the element is drawn upon it (like what CLNE does)
#define PROP_NOCTYPEDRAW	0x100000 // 2^20 When this element is drawn upon with, do not set ctype (like BCLN for CLNE)}}



{tags:Elements, Properties}</ins>
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:28:50 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 
<ins>
[Here's a list of all Properties flags and their descriptions.|Properties]</ins>

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}
<ins></ins>

!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS Simulation* sim, int index, int x, int y, 
                         int surround_space, int no_type, Particle *parts, 
                         int pmap[YRES][XRES]}}

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

Update = &amp;amp;Element_BCOL::update;

!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}

{tags:Elements, Properties}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:25:51 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

! Name

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}



!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}

!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS Simulation* sim, int index, int x, int y, 
                         int surround_space, int no_type, Particle *parts, 
                         int pmap[YRES][XRES]}}

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

Update = &amp;amp;Element_BCOL::update;

!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}
<ins>
{tags:Elements, Properties}</ins>
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:24:36 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close enough to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;, in order to tell the executable what your element ID variable will be called inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

<del>&amp;lt;span id=&quot;properties.Name&quot;&gt;string(4) Name&amp;lt;/span&gt;</del><ins>! Name</ins>

This is the element's name outside the Lua API. It's what will be drawn on top of the element's button and what one will use to refer to the element in the exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}
<ins></ins>


!  Colour

This will be the particle's colour in RENDER_BASC mode as well as the element button's. It has a format similar to CSS colours: `0xRRGGBB` where every letter specifies which colour the byte specifies, so 0xFF0000 would have exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access the element without it being in the menu via alt-click sampling. A value of 1 means that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are placed in reverse order, with the rightmost being the smallest ID generally, and new elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can use a value of 0 to disable elements softly while still breaking every save in existence. In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a magical constant that makes airdrag properly work with different pressure grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply bysetting this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is removed and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to simulate heating air around (this was made way before ambient heat). Another property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. An extremely small number, sometimes as small as 0.000001f
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it checks how flammable nearby particles are and uses that as a number to say how quickly and how likely this particle will turn into fire. Particles are entirely nonflammable at 0 and from there on become increasingly more flammable.

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of like C4 does: like burning except it spreads around very quickly, often in a single tick, creating more pressure than normal. You can obviously do this in your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid is at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard way then this is the heat the element will have once it's created. The value's in Kelvin though, so you'll have to convert if you don't like it. You could also just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct instead of heatconduct. You can use a value from 0 (none at all) to 255 (really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection button! Meant to be an element's description semantically speaking, however. So use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it doesn't have a state. The only place I've seen it used so far is STKM figuring out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of special flags that enable or disable things relating to this element. Some of the things include whether you can 'paint' ctypes onto this element, whether it can be 'painted' as a ctype onto other elements, stuff to do with neutron movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy enough, right? 

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}

!  Update

This is a function that will be called for every particle once per tick. You can do various things here with the simulation and particles around you, and so this is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others through them):

(in C++):
{{#define UPDATE_FUNC_ARGS Simulation* sim, int index, int x, int y, 
                         int surround_space, int no_type, Particle *parts, 
                         int pmap[YRES][XRES]}}

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

Update = &amp;amp;Element_BCOL::update;

!  Graphics

For how this works in Lua, you are passed four variables and expected to return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function anymore, since the color won't change anyway. Aside that, all properties are the same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:24:16 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close <del>
enough</del><ins>enough</ins> to the sim.partProperty or tpt.set_property function

!  Identifier

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;,<del>
in</del><ins> in</ins> order to tell the executable what your element ID variable will be called<del>
inside</del><ins> inside</ins> Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

&amp;lt;span id=&quot;properties.Name&quot;&gt;string(4) Name&amp;lt;/span&gt;

This is the element's name outside the Lua API. It's what will be drawn on top <del>
of</del><ins>of</ins> the element's button and what one will use to refer to the element in the <del>
exclamation-point</del><ins>exclamation-point</ins> command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}


!  Colour

This will be the particle's colour in RENDER_BASC mode as well as <del>
the</del><ins>the</ins> element button's. It has a format similar to CSS colours: `0xRRGGBB` where <del>
every</del><ins>every</ins> letter specifies which colour the byte specifies, so 0xFF0000 would have <del>
exactly</del><ins>exactly</ins> 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

!  MenuVisible

Sets or gets whether this element gets placed into a menu. You can still access<del>
the</del><ins> the</ins> element without it being in the menu via alt-click sampling. A value of 1<del>
means</del><ins> means</ins> that the item will have a button placed into some menu.

!  MenuSection

Which menu section the element button will be placed under. Element buttons are <del>
placed</del><ins>placed</ins> in reverse order, with the rightmost being the smallest ID generally, and <del>
new</del><ins>new</ins> elements will be added to the left.

!  Enabled

If the element is enabled to be used in-game at all, use a value of 1. You can <del>
use</del><ins>use</ins> a value of 0 to disable elements softly while still breaking every save in <del>
existence.</del><ins>existence.</ins> In general, keep it as 1.

!  Advection

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

!  AirDrag

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a <del>
magical</del><ins>magical</ins> constant that makes airdrag properly work with different pressure <del>
grid</del><ins>grid</ins> sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

!  AirLoss

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply <del>by
setting</del><ins>bysetting</ins> this value to zero. Pressure can jump around a bit, too!

!  Loss

How much speed the particle loses every frame. 1 means that no velocity is <del>
removed</del><ins>removed</ins> and anything less means that more velocity will be removed.

!  Collision

When this particle hits something, this value is used to determine new velocity.
 
!  Gravity

This determines how strongly gravity affects this particle. ANAR has this set as <del>
negative</del><ins>negative</ins> for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

!  Diffusion

(To be written)

!  HotAir

How much the particle increases the pressure around itself by, in order to <del>
simulate</del><ins>simulate</ins> heating air around (this was made way before ambient heat). Another <del>
property</del><ins>property</ins> that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. <del>
An</del><ins>An</ins> extremely small number, sometimes as small as 0.000001f<del>
</del>
Note: ICE has this as a negative value - it slightly reduces pressure!

!  Falldown

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

!  Flammable

How well this particle catches on fire. FIRE has a basic reaction in  which it<del>
checks</del><ins> checks</ins> how flammable nearby particles are and uses that as a number to say how<del>
quickly</del><ins> quickly</ins> and how likely this particle will turn into fire. Particles are<del>
entirely</del><ins> entirely</ins> nonflammable at 0 and from there on become increasingly more<del>
flammable.</del><ins> flammable.</ins>

!  Explosive

Sets default behaviour on if and how this element explodes. It works kind of<del>
like</del><ins> like</ins> C4 does: like burning except it spreads around very quickly, often in a<del>
single</del><ins> single</ins> tick, creating more pressure than normal. You can obviously do this in<del>
your</del><ins> your</ins> update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

!  Meltable

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

!  Hardness

How well acid affects this particle. The bigger this value is, the better acid<del>
is</del><ins> is</ins> at eating through it. 

!  Weight

Particle weight. A looong time ago there used to be a table that kept track<del>
of</del><ins> of</ins> what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

!  Temperature

The spawning temperature of this element. If you draw or create it in a standard<del>
way</del><ins> way</ins> then this is the heat the element will have once it's created. The value's <del>
in</del><ins>in</ins> Kelvin though, so you'll have to convert if you don't like it. You could also<del>
just</del><ins> just</ins> do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

!  HeatConduct

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct<del>
instead</del><ins> instead</ins> of heatconduct. You can use a value from 0 (none at all) to 255 <del>
(really</del><ins>(really</ins> good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

!  Description

It's the text that the element shows when you put your mouse over its selection<del>
button!</del><ins> button!</ins> Meant to be an element's description semantically speaking, however. So<del>
use</del><ins> use</ins> it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


!  State

It's just a flag to tell which state the element's in right now, or even if it <del>
doesn't</del><ins>doesn't</ins> have a state. The only place I've seen it used so far is STKM figuring<del>
out</del><ins> out</ins> which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


!  Properties

Every kind of element property other than the ones above. It's just a bunch of <del>
special</del><ins>special</ins> flags that enable or disable things relating to this element. Some of<del>
the</del><ins> the</ins> things include whether you can 'paint' ctypes onto this element, whether it<del>
can</del><ins> can</ins> be 'painted' as a ctype onto other elements, stuff to do with neutron <del>
movements,</del><ins>movements,</ins> etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy <del>
enough,</del><ins>enough,</ins> right? 

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}

!  Update

This is a function that will be called for every particle once per tick. You can<del>
do</del><ins> do</ins> various things here with the simulation and particles around you, and so this<del>
is</del><ins> is</ins> an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others <del>
through</del><ins>through</ins> them):

(in C++):
{{#define UPDATE_FUNC_ARGS Simulation* sim, int index, int x, int y, 
                         int surround_space, int no_type, Particle *parts, 
                         int pmap[YRES][XRES]}}

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

Update = &amp;amp;Element_BCOL::update;

!  Graphics

For how this works in Lua, you are passed four variables and expected to <del>
return</del><ins>return</ins> a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function <del>any-
more,</del><ins>anymore,</ins> since the color won't change anyway. Aside that, all properties are the <del>
same</del><ins>same</ins> as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. <del>
Bluntly</del><ins>Bluntly</ins> assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function<del>
parameters.</del><ins> parameters.</ins>

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:20:27 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff">{{class Element
{
public:
  const char *Identifier;
  const char *Name;
  pixel Colour;
  float Advection;
  float AirDrag;
  float AirLoss;
  float Loss;
  float Collision;
  float Gravity;
  float Diffusion;
  float HotAir;
  int Falldown;
  int Flammable;
  int Explosive;
  int Meltable;
  int Hardness;
  int MenuVisible;
  int Enabled;
  int Weight;
  int MenuSection;
  float Temperature;
  unsigned char HeatConduct;
  const char *Description;
  unsigned int Properties;
  char State;

  int (*Update) (UPDATE_FUNC_ARGS);
  int (*Graphics) (GRAPHICS_FUNC_ARGS);


  float HighPressure;
  int HighPressureTransition;
  float LowPressure;
  int LowPressureTransition;
  float HighTemperature;
  int HighTemperatureTransition;
  float LowTemperature;
  int LowTemperatureTransition;

  // not going to cover these:
  VideoBuffer * (*IconGenerator)(int, int, int);
  Element();
  virtual ~Element() {}
  static int defaultGraphics(GRAPHICS_FUNC_ARGS);
  static int legacyUpdate(UPDATE_FUNC_ARGS);

  static std::vector&amp;lt;StructProperty&gt; GetProperties();
};}}

The types apply to Lua as well, as you will have to pass a value of a type close 
enough to the sim.partProperty or tpt.set_property function

<del>!! Identifier</del><ins>!  Identifier</ins>

Element's name on the Lua API. You usually set it to &amp;lt;NAMESPACE&amp;gt;_PT_&amp;lt;ELEMENTNAME&amp;gt;,
in order to tell the executable what your element ID variable will be called
inside Lua.

An example value could be: 

{{Identifier = &quot;DEFAULT_PT_BCOL&quot;; }}

In Lua scripting, you can set it with: 

{{local element_id = elements.allocate(&quot;DEFAULT&quot;, &quot;BCOL&quot;)}}

&amp;lt;span id=&quot;properties.Name&quot;&gt;string(4) Name&amp;lt;/span&gt;

This is the element's name outside the Lua API. It's what will be drawn on top 
of the element's button and what one will use to refer to the element in the 
exclamation-point command interface.

An example value could be: 

{{Name = &quot;BCOL&quot;;}}


<del>!! Colour</del><ins>!  Colour</ins>

This will be the particle's colour in RENDER_BASC mode as well as 
the element button's. It has a format similar to CSS colours: `0xRRGGBB` where 
every letter specifies which colour the byte specifies, so 0xFF0000 would have 
exactly 255/255 tones red, and 0 tones both green and blue.

You can set it in C++ by using the PIXPACK preprocessor macro: 

{{Colour = PIXPACK(0x333333);}}

...and in Lua by using elements.property with the same hexadecimal value.

<del>!! MenuVisible</del><ins>!  MenuVisible</ins>

Sets or gets whether this element gets placed into a menu. You can still access
the element without it being in the menu via alt-click sampling. A value of 1
means that the item will have a button placed into some menu.

<del>!! MenuSection</del><ins>!  MenuSection</ins>

Which menu section the element button will be placed under. Element buttons are 
placed in reverse order, with the rightmost being the smallest ID generally, and 
new elements will be added to the left.

<del>!! Enabled</del><ins>!  Enabled</ins>

If the element is enabled to be used in-game at all, use a value of 1. You can 
use a value of 0 to disable elements softly while still breaking every save in 
existence. In general, keep it as 1.

<del>!! Advection</del><ins>!  Advection</ins>

How much the particle is pushed by moving air. Normally 0 for solids, and up to
1 for other elements. It can be negative, ANAR and DEST do this so it goes 
towards pressure.

<del>!! AirDrag</del><ins>!  AirDrag</ins>

How much air the particle &quot;drags&quot; along with itself when moving. CFDS is a 
magical constant that makes airdrag properly work with different pressure 
grid sizes. Thus the definition should always be multiplied by that.

For example,
{{AirDrag = 0.004f * CFDS;}}

<del>!! AirLoss</del><ins>!  AirLoss</ins>

How much it reduces velocity. 1 for no effect, 0 for full effect.

Note: TTAN is not powered by this and this means you can't make TTAN simply by
setting this value to zero. Pressure can jump around a bit, too!

<del>!! Loss</del><ins>!  Loss</ins>

How much speed the particle loses every frame. 1 means that no velocity is 
removed and anything less means that more velocity will be removed.

<del>!! Collision</del><ins>!  Collision</ins>

When this particle hits something, this value is used to determine new velocity.
 
<del>!! Gravity</del><ins>!  Gravity</ins>

This determines how strongly gravity affects this particle. ANAR has this set as 
negative for example!

{{// No effect
Gravity = 0f; 
// Floats upwards at normal gravity's speed
Gravity = -1f; 
// Floats downwards almost at normal gravity's speed
Gravity = 0.999f;}}

<del>!! Diffusion</del><ins>!  Diffusion</ins>

(To be written)

<del>!! HotAir</del><ins>!  HotAir</ins>

How much the particle increases the pressure around itself by, in order to 
simulate heating air around (this was made way before ambient heat). Another 
property that's mostly only used for gasses, but VENT/VACU have theirs at (-)0.010f. 
An extremely small number, sometimes as small as 0.000001f

Note: ICE has this as a negative value - it slightly reduces pressure!

<del>!! Falldown</del><ins>!  Falldown</ins>

Sets what kind of default moving code this particle will use.
0 = Solid  (or rather, no 'regular' movement!)
1 = Powder 
2 = Liquid 

<del>!! Flammable</del><ins>!  Flammable</ins>

How well this particle catches on fire. FIRE has a basic reaction in  which it
checks how flammable nearby particles are and uses that as a number to say how
quickly and how likely this particle will turn into fire. Particles are
entirely nonflammable at 0 and from there on become increasingly more
flammable.

<del>!! Explosive</del><ins>!  Explosive</ins>

Sets default behaviour on if and how this element explodes. It works kind of
like C4 does: like burning except it spreads around very quickly, often in a
single tick, creating more pressure than normal. You can obviously do this in
your update code though...

0 = no default explosion behavior.
1 = Explodes with fire.
2 = Explodes with &gt;2.5 pressure as well as fire.

<del>!! Meltable</del><ins>!  Meltable</ins>

Does this particle melt into LAVA? (I'm not sure about the threshold just yet.)

<del>!! Hardness</del><ins>!  Hardness</ins>

How well acid affects this particle. The bigger this value is, the better acid
is at eating through it. 

<del>!! Weight</del><ins>!  Weight</ins>

Particle weight. A looong time ago there used to be a table that kept track
of what element sank under which and which it stayed on top of.

Below is an estimate to which range TPT's default elements' weights belong:

    1 = gasses.
    2 = very light powders. DUST?
 0-49 = liquids.
50-99 = default powders.
  100 = solids.
   -1 = energy particles (PHOT/NEUT/ELEC/PROT).

<del>!! Temperature</del><ins>!  Temperature</ins>

The spawning temperature of this element. If you draw or create it in a standard
way then this is the heat the element will have once it's created. The value's 
in Kelvin though, so you'll have to convert if you don't like it. You could also
just do addition if you're in C++ or even Lua, it gets optimized out. 

{{// #define R_TEMP 22.0f
Temperature = R_TEMP + 273.15f + 0.00f;}}

<del>!! HeatConduct</del><ins>!  HeatConduct</ins>

Shows how well this particle transfers heat. In tpt.el.*, it's called hconduct
instead of heatconduct. You can use a value from 0 (none at all) to 255 
(really good). 

INSL and FRME have this as 0. 
INSL/INST/HSWC and a few more have 251.

<del>!! Description</del><ins>!  Description</ins>

It's the text that the element shows when you put your mouse over its selection
button! Meant to be an element's description semantically speaking, however. So
use it as that :)

{{Description = &quot;Broken Coal. Heavy particles. See COAL&quot;;}}


<del>!! State</del><ins>!  State</ins>

It's just a flag to tell which state the element's in right now, or even if it 
doesn't have a state. The only place I've seen it used so far is STKM figuring
out which particles it can spark...? 

(elements.)ST_SOLID = Solid
(elements.)ST_LIQUID = Liquid 
(elements.)ST_GAS = Gas 
(elements.)ST_NONE = None of the above. 

{{State = ST_SOLID; }}


<del>!! Properties</del><ins>!  Properties</ins>

Every kind of element property other than the ones above. It's just a bunch of 
special flags that enable or disable things relating to this element. Some of
the things include whether you can 'paint' ctypes onto this element, whether it
can be 'painted' as a ctype onto other elements, stuff to do with neutron 
movements, etc. 

If you want to use multiple at the same time, apply binary OR to them! Easy 
enough, right? 

{{Properties = TYPE_PART | PROP_NEUTPENETRATE;}}

<del>!! Update</del><ins>!  Update</ins>

This is a function that will be called for every particle once per tick. You can
do various things here with the simulation and particles around you, and so this
is an useful function for all sorts of updating purposes. 

You can see the various objects you can access from the function (and others 
through them):

(in C++):
{{#define UPDATE_FUNC_ARGS Simulation* sim, int index, int x, int y, 
                         int surround_space, int no_type, Particle *parts, 
                         int pmap[YRES][XRES]}}

(in Lua): number index, number x, number y, number surround_space, number nt

Once you define your function, the assignment to this property is very simple: 

Update = &amp;amp;Element_BCOL::update;

<del>!! Graphics</del><ins>!  Graphics</ins>

For how this works in Lua, you are passed four variables and expected to 
return a dozen more.

Parameters: index, colr, colg, colb
Return values: cache, pixel_mode, cola, colr, colg, colb, firea, firer, 
               fireg, and fireb.

The cache variable tells the graphics renderer not to call this function any-
more, since the color won't change anyway. Aside that, all properties are the 
same as what C++ should have them.

In C++ however, you are passed pointers with all the values to be returned. 
Bluntly assign to them as you would to any other pointer.

{{*colr = 255;}}

Also check out all the different arguments you will get as your function
parameters.

{{#define GRAPHICS_FUNC_ARGS Renderer * ren, Particle *cpart, int nx, int ny, 
     int *pixel_mode, int *cola, int *colr, int *colg, 
     int *colb, int *firea, int *firer, int *fireg, int *fireb}}
</pre></description>
	</item>

	<item>
	  <title>Element properties</title>
	  <pubDate>Thu, 03 Jul 2014 11:19:56 +0000</pubDate>
	  <link>http://localhost:80/tptelements/wiki/index.php?page=Element+properties</link>
	  <description><pre id="diff"></pre></description>
	</item>
</channel>
</rss>